#!/usr/bin/ol --run

;;;
;;; Radamsa - a general purpose test data fuzzer
;;;

;; todo: factor to modules
;; todo: be systematic in naming of fuzzers and allow regexps like -f all,t*=3
;; todo: make a priority adjustment pass and allow it to pass information back
;; todo: use -g all,sample=0 to disable sample generator?
;; todo: stream fuzzer: lex perm/drop/ins -> l<name> <- 2-pass autodetect
;; todo: stream fuzzer: cut section around delimiters and permute some slots (2-pass)
;; todo: stream fuzzer: cut&fill with probabilities
;; todo: stream fuzzer: local permu transform
;; todo: stream muxer: 2-stream permu
;; todo: stream muxer: 2-stream surf (lazy stree)
;; todo: stream muxer: loops 0/2/n
;; todo: local grafu
;; todo: add something like --usual-suspects, --everything, --fast etc preselections
;; todo: ref preselections, add proper support for them to lib-args
;; todo: have a look at mutation distributions on larger files. not sensible yet!
;; todo: muxers could return F when can't do anything, so that the meta could be removed
;; todo: node infos should be ffs of static values like name, description etc to allow something like $ radamsa --list-modules
;; maybe: if the case stream would use for example seeds generated by a lagged fibonacci generator, one could seek in O(log n)
;; missing: comma-separated output lists

;; fuzzer node info → ff of (name → str, description → text, meta → meta)
(define version-str "Radamsa 0.2.1c")
(define avg-block-size 4096)

(import lib-args)

;; benchmarking & debugging utils

(define (renderer ob tl) 
   (render render ob tl))

(define (timed-thunk msg thunk)
   (lets
      ((pre (time-ms))
       (res (thunk))
       (elapsed (- (time-ms) pre)))
      (mail stderr
         (foldr renderer '(10) 
            (list "BENCH: " msg ": " elapsed "ms")))
      res))

(define-syntax timed-not ;; output timings to stderr
   (syntax-rules ()
      ((timed comment code)
         (timed-thunk comment (λ () code)))))

(define-syntax timed ;; kill the extra code
   (syntax-rules ()
      ((timed-not comment code) code)))

;; todo: stream muxer: cat a b → a ++ b, seen some bugs that needed this

(define rval-failed-to-start-modules 1)
(define rval-crashed 127) ;; in-owl thread crash after detecting an error

(define (car> a b) (> (car a) (car b)))

(define (pop-rand rs)
   (lets ((digit rs (uncons rs F))) rs))

;; force and send a stream to a port
(define (mail-blocks str port n)
   (cond
      ((pair? str)
         (lets
            ((block str str)
             (size (sizeb block)))
            (if (not (eq? size 0))
               (mail port block))
            (mail-blocks str port (+ n size))))
      ((null? str) n)
      (else (mail-blocks (str) port n))))

;; ll port → ok? n-written, temporarily always ok
(define (send-stream data port)
   (let ((res (mail-blocks data port 0)))
      (flush-port port) ; <- only necessary for stdout, since others are autoflushed on close soon
      (if res
         (values True res)
         (values False False))))

;; functions that get metadata about generated data
(define (record-meta/stderr n name info len)
   (mail stderr (foldr renderer '(10) (list " " n ": " name " → " info ": " len "b"))))

(define (record-meta/not n name info len) 42)

;; todo: pass the meta recorder here
(define (get-stdout-fd n)
   (pair 
      (λ (ll record-meta)
         (record-meta n "" (car ll) "to-be-written/stdout") ;; <- when testing new crash-prone ones
         (lets ((ok? w (send-stream (cdr ll) stdout)))
            (record-meta n "" (car ll) w)))
      (get-stdout-fd (+ n 1))))

(define (render-ip bvec)
   (runes->string
      (foldr
         (λ (byte tl)
            (render render byte (if (null? tl) tl (cons 46 tl))))
         null bvec)))

(define (render-ip-port bvec port)
   (runes->string
      (foldr
         (λ (byte tl)
            (render render byte (if (null? tl) tl (cons 46 tl))))
         (cons 58 (render render port null))
         bvec)))

;; todo: parameterize writers to take the meta recorder
(define (file-writer pat)
   (λ (nth)
      (λ (node record-meta)
         (lets ((info ll node))
            (define path
               (runes->string
                  (str-foldr
                     (λ (char tl)
                        (cond
                           ((null? tl)
                              (cons char tl))
                           ((eq? char 37) ; %
                              (case (car tl)
                                 ((110) (render render nth (cdr tl))) ; %n
                                 ((102) (render render (get info 'name "anonimasu") (cdr tl))) ; %f
                                 (else (error "Unknown pattern in output path: " (list->string (cons char tl))))))
                           (else (cons char tl))))
                     null pat)))
            (define port 
               (open-output-file path))
            (record-meta nth path info "to-be-written") ;; <- when testing new crash-prone ones
            (if port
               (lets ((ok? written (send-stream ll port)))
                  (if ok?
                     (record-meta nth path info written)
                     (record-meta nth path info False))
                  (close-port port))
               (error "Cannot write to " path))))))

(define (in-range? min max)
   (λ (x) (and (<= min x) (<= x max))))

(define (make-tcp-connection ip port)
   (λ (n)
      (λ (node record-meta)
         (let loop ()
            (lets ((status wrote (tcp-send ip port (cdr node))))
               (cond
                  ((eq? status 'ok)
                     (record-meta n (render-ip-port ip port) (car node) wrote))
                  ((eq? status 'connect-error) ;; other end not ready to receive connection
                     (wait 100)
                     (loop))
                  ((and (eq? n 0) (eq? status 'write-error))
                     ;; hung up before accepting any data. retry.
                     ;; added to avoid a weird 'connection reset by peer' happening in unit tests.
                     (loop))
                  (else
                     ;; write error byt we did write something
                     (show "WRITE ERROR AFTER " wrote)
                     (record-meta n (render-ip-port ip port) (car node) 
                        status ;; <- could say "disconnected after n"
                        ))))))))

(define (serve-node numbered)
   (λ (node record-meta)
      ;; todo: do a few unblocking reads because the client might block until a request is received
      (lets 
         ((nth cli numbered)
          (ip fd cli))
         (lets 
            ((ip fd cli)
             (ok? np (blocks->fd (cdr node) fd))) ; <- closes fd
            (record-meta nth (render-ip ip) (car node) np)))))

;; str → ((info . fd) ...) | False
(define (make-output-stream str)
   (cond
      ((equal? str "-")
         (get-stdout-fd 1))
      ((/^:[0-9]+$/ str)
         (let ((port (string->integer (s/^:// str))))
            (if (and port (>= port 0) (< port 65536))
               (let ((clis (tcp-clients port)))
                  (if clis
                     (lmap serve-node (lzip cons (lnums 1) clis))
                     False))
               (begin
                  (show "Bad port " port)
                  False))))
      ((/^[0-9]{1,3}(\.[0-9]{1,3}){3}:[0-9]+$/ str)
         (lets
            ((ip-port (c/:/ str)) ;; todo: later these become 2-valued functions
             (port (string->integer (cadr ip-port)))
             (addr (map string->integer (c/\./ (car ip-port)))))
            (cond
               ((not (all (in-range? 0 255) addr))
                  (show "Bad ip address: " addr)
                  null)
               ((not ((in-range? 0 65535) port))
                  (show "Bad port: " port)
                  False)
               (else
                  (lmap (make-tcp-connection (list->vector addr) port)
                     (lnums 1))))))
      (else
         (lmap (file-writer str) (lnums 1)))))

(define basic-cl-opts
   `((help "-h" "--help" comment "Show this thing.")
     (output "-o" "--output" has-arg default "-" cook ,make-output-stream
         comment "Where to write the generated data?")
     (count "-n" "--count" cook ,string->integer check ,(λ (x) (> x 0))
         default "1" comment "How many outputs to generate?")
     (seed "-s" "--seed" has-arg comment "Random seed (any string).")
     (verbose "-v" "--verbose" comment "Be verbose when running.")
     (version "-V" "--version" comment "Show version information.")
     (examples "-E"  "--examples" comment "Show usage examples.")
     (advanced "-H"  "--big-help" comment "Show more options.")
))

(define advanced-cl-opts
   (append basic-cl-opts
      `((fuzzers "-f" "--fuzzers" has-arg default "drop,inc,dec,dup,flip,stut=3,num=4,u8ins=2,perm=2,surf=4,u8ed,tdup=2,tdel=2,tdur=2,tswal=2"
            comment "Which stream fuzzers to run? (pass help to list options)")
        (generators "-g" "--generators" has-arg default "sample=50,flat,random" 
            comment "Which stream generators to run? (pass help to list options)")
        (polymerase "-p" "--polymerase" has-arg default "onced" 
            comment "Which stream mutator patterns to use? (pass help to list options)")
        (muxers "-m" "--muxers" has-arg default "swap=4,cat,min,max,avg" 
            comment "Which stream muxers to use? (pass help to list options)")
        (muxer-polymerase "-P" "--muxer-polymerase" has-arg default "once" 
            comment "Which muxer mutator patterns to use? (pass help to list options)")
        (seek "-S" "--seek" has-arg cook ,string->integer check ,(λ (x) (>= x 0))
            comment "Skip n outputs." default "0") ;; temporarily disabled due to a bug (likely fd leak)
        (single F "--single" comment "Use only one data stream per output."))))

(define command-line-rules
   (cl-rules advanced-cl-opts))

(define usage-text "Usage: radamsa [option] [sample-path] ...")

(define (print-usage-text advanced?)
   (print usage-text)
   (print-rules (if advanced? command-line-rules (cl-rules basic-cl-opts))))

;; () → string
(define (urandom-seed)
   (let ((fd (open-input-file "/dev/urandom"))) ;; False if not there
      (if fd
         (let ((data (interact fd 8)))
            (close-port fd)
            (if (vector? data)
               (list->string 
                  (render render (fold (λ (n d) (+ d (<< n 8))) 0 data) null))
               False))
         False)))

;; () → string (decimal number)
(define (time-seed)
   (list->string (render render (time-ms) null)))

;; get a seed if none was given explicitly (use /dev/urandom or current time in ms)
(define (add-seed opts)
   (put opts 'seed
      (or (urandom-seed) (time-seed))))

;; str → integer
(define (string->seed str)
   (if (string? str)
      (fold (λ (seed digit) (* (+ digit 1) (+ seed 1))) 1 (str-iter str))
      (error "bad seed: " str)))

;; str → str | (name . priority)
(define (try-split-priority str)
   (lets ((parts (c/=/ str)))
      (cond
         ((= (length parts) 1)
            ;; no priority given. default to 1 (lowest).
            (cons 1 (car parts)))
         ((= (length parts) 2)
            (let ((pri (string->integer (cadr parts))))
               (if (and pri (> pri 0))
                  (cons pri (car parts))
                  str)))
         (else str))))

(define (split-priorities selection opts paths fail)
   (lets
      ((mods (keep (λ (x) (> (string-length x) 0)) (c/,/ selection))) ;; split
       (pris (map try-split-priority mods))
       (bads (keep string? pris)))
      (if (null? bads)
         pris
         (begin
            (for-each (λ (x) (show "Bad module selection: " x)) bads)
            (print "Modules selection is a comma-separated list of module names optionally followed by weights.")
            (print "For example -e foo,bar,baz=2 will use baz about as often as foo and bar combined.")
            (print "Use $ radamsa -e help to list options")
            (fail False)))))

(define (iterate thing)
   (pair thing (iterate thing)))

;; iterate the same thing
(define (simple-node name value)
   (let ((node (cons name value)))
      (iterate node)))

;; iterate a fuzzer function that acts like a lfold over random states
;; rs name value → (name . ((name . (val rs)) (name . (var . rs')) ...))
(define (rs-fold-node name value)
   (cons name
      (λ (rs paths opts)
         (let loop ((rs rs))
            (pair (cons name (value rs))
               (loop (pop-rand rs)))))))

;;; Stream fuzzers -----------------------------------------------------------

(define (byte-vector->list bvec)
   (let ((n (sizeb bvec)))
      (if (eq? n 0)
         null
         (let loop ((pos (- n 1)) (out null))
            (if (eq? pos 0)
               (cons (refb bvec pos) out)
               (lets ((posp _ (fx- pos 1)))
                  (loop posp (cons (refb bvec pos) out))))))))

;; todo: add zero width joiners, different length leading blank padding bytes etc
(define funny-unicode
   (list->tuple
      (append
         (list ;; some manual ones
            (list 239 191 191)     ;; 65535
            (list 240 144 128 128) ;; 65536
            (list #xef #xbb #xbf)  ;; the canonical utf8 bom
            (list #xfe #xff)       ;; utf16 be bom
            (list #xff #xfe)       ;; utf16 le bom
            (list 0 0 #xff #xff)   ;; ascii null be
            (list #xff #xff 0 0)   ;; ascii null le
            (list 43 47 118 56)    ;; and some others from wikipedia
            (list 43 47 118 57) (list 43 47 118 43) (list 43 47 118 47)
            (list 247 100 76) (list 221 115 102 115) (list 14 254 255) (list 251 238 40)
            (list 251 238 40 255) (list 132 49 149 51))
         (map ;; some valid points and ranges
            (λ (codepoint)
               (render render (list->string (list codepoint)) null)) ;; <- make UTF-8 repr
            (fold
            (λ (tl node)
                  (if (pair? node) ;; inclusive range
                     (append (iota (car node) 1 (+ (cdr node) 1)) tl)
                     (cons node tl)))
               null
               '((#x0009 . #x000d) #x00a0 #x1680 #x180e (#x2000 . #x200a) #x2028 #x2029 #x202f #x205f
                 #x3000 (#x200e . #x200f) (#x202a . #x202e) (#x200c . #x200d) #x0345 #x00b7 (#x02d0 . #x02d1) 
                 #xff70 (#x02b0 . #x02b8) #xfdd0 #x034f (#x115f . #x1160) (#x2065 . #x2069) #x3164 #xffa0
                 #xe0001 (#xe0020 . #xe007f) (#x0e40 . #x0e44) #x1f4a9))))))

;; clone a byte vector to a list and edit at given position (using primops since this is heavily used)
(define (edit-byte-vector bvec edit-pos fn)
   (let ((len (sizeb bvec)))
      (if (eq? len 0)
         bvec
         (let loop ((pos (- len 1)) (out null))
            (let ((val (refb bvec pos)))
               (if (eq? pos edit-pos)
                  (if (eq? pos 0)
                     (list->byte-vector (fn val out))
                     (lets ((pos _ (fx- pos 1)))
                        (loop pos (fn val out))))
                  (if (eq? pos 0)
                     (list->byte-vector (cons val out))
                     (lets ((pos _ (fx- pos 1)))
                        (loop pos (cons val out))))))))))

(define (digit-val d)
   (cond
      ((lesser? d 48) F)
      ((lesser? 57 d) F)
      (else (- d 48))))

; → digit|F tail
(define (get-num lst)
   (let loop ((lst lst) (n 0) (digits 0))
      (cond
         ((null? lst)
            (if (eq? digits 0)
               (values F null)
               (values n null)))
         ((digit-val (car lst)) =>
            (λ (d) (loop (cdr lst) (+ d (* n 10)) (+ digits 1))))
         ((eq? digits 0)
            (values F lst))
         (else
            (values n lst)))))

;; copy from pos up to end (not countin it)
(define (copy-range pos end tail)
   (if (eq? pos end)
      tail
      (cons (car pos) (copy-range (cdr pos) end tail))))

;; fixme: simple placeholder
(define (mutate-num rs num)
   (lets ((rs n (rand rs 16)))
      (cond
         ((eq? n 0)  (values rs (+ n 1)))
         ((eq? n 1)  (values rs (- n 1)))
         ((eq? n 2)  (values rs 0)) ;; todo, pack funny nums to a list and reduce opts
         ((eq? n 3)  (values rs 1))
         ((eq? n 4)  (values rs #xff))
         ((eq? n 5)  (values rs #x100))
         ((eq? n 6)  (values rs #xffff))
         ((eq? n 7)  (values rs #x10000))
         ((eq? n 8)  (values rs #x7fffffff))
         ((eq? n 9)  (values rs #x80000000))
         ((eq? n 10) (values rs #xffffffff)) ;; todo 64-bit also when using a list
         ((eq? n 11) (values rs #x100000000))
         ((eq? n 12)
            (lets ((rs m (rand rs (* n 2))))
               (values rs (- n m))))
         (else
            (lets
               ((rs n (rand-range rs 1 129))
                (rs n (rand-log rs n)))
               (values rs (+ num n)))))))

(define (mutate-a-num rs lst nfound)
   (if (null? lst)
      (lets ((rs which (rand rs nfound)))
         ;; choose which to mutate (or 0 if none)
         (values rs which null))
      (lets ((valp lstp (get-num lst)))
         (if valp
            (lets ((rs which tail (mutate-a-num rs lstp (+ nfound 1))))
               (if (eq? which 0) ;; i won
                  (lets
                     ((rs new (mutate-num rs valp))
                      (new-lst (render render new tail)))
                     (values rs -1 (render render new tail)))
                  (values rs (- which 1)
                     (copy-range lst lstp tail))))
            (lets ((rs which tail (mutate-a-num rs (cdr lst) nfound)))
               (values rs which (cons (car lst) tail)))))))

;; todo: pack stream fuzzers to the list itself
(define (sed-num rs)
   (λ (ll)
      (lets
         ((lst (vec->list (car ll)))
          (rs n lst (mutate-a-num rs lst 0)))
         (cons (list->byte-vector lst) (cdr ll)))))

(define (sed-star rs) ;; test fuzzer, replaces a character with *
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons (edit-byte-vector (car ll) p (λ (old tl) (cons 42 tl))) (cdr ll)))))

(define (sed-drop rs) ;; droa byte
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons (edit-byte-vector (car ll) p (λ (old tl) tl)) (cdr ll)))))

(define (sed-inc rs) ;; increment a byte mod 256
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons (edit-byte-vector (car ll) p (λ (old tl) (cons (band 255 (+ old 1)) tl))) (cdr ll)))))

(define (sed-flip rs) ;; flip a bit
   (λ (ll)
      (lets 
         ((rs p (rand rs (sizeb (car ll))))
          (rs b (rand rs 8)))
         (cons (edit-byte-vector (car ll) p (λ (old tl) (cons (bxor (<< 1 b) old) tl))) (cdr ll)))))

;;; sed-tree-* utils

(define usual-delims ; <- could be settable from command line
   (list->ff
      '((40 . 41)    ; ()
        (91 . 93)    ; []
        (60 . 62)    ; <>
        (123 . 125)  ; {}
        (34 . 34)    ; ""
        (39 . 39)))) ; ''
      
(define (grow lst close rout)
   (if (null? lst)
      (values (reverse rout) False) ;; out of data, didn't find close. return partial parse.
      (lets ((hd lst lst))
         (cond
            ((eq? hd close)
               ;; match complete, return with rest of list
               (values (reverse (cons close rout)) lst))
            ((get usual-delims hd F) =>
               (λ (next-close)
                  (lets ((this lst (grow lst next-close (list hd))))
                     (if lst ;; we didn't run out of data and this is a single tree node
                        (grow lst close (cons this rout))
                        ;; we ran out of data. this is a list of partial parses (having the data of 
                        ;; lst after hd in some form) which we want to preserve as tail
                        (values (cons hd this) False)))))
            (else ;; add one byte to this node
               (grow lst close (cons hd rout)))))))

;; count how many list nodes are in a tree structure
(define (count-nodes lst)
   (let loop ((lst lst) (n 0))
      (cond
         ((null? lst) n)
         ((pair? (car lst))
            (loop (cdr lst)
               (loop (car lst) (+ n 1))))
         (else
            (loop (cdr lst) n)))))

;; lst → a list of lists (not counting tails) in lst, when walked recursively, not counting lst itself
(define (sublists lst)
   (let loop ((lst lst) (found null))
      (if (null? lst) 
         found
         (let ((hd (car lst)))
            (if (pair? hd)
               (loop (cdr lst) 
                  (loop hd (cons hd found)))
               (loop (cdr lst) found))))))

(define (pick-sublist rs lst)
   (let ((subs (sublists lst)))
      (if (null? subs)
         (values rs False)
         (lets ((rs n (rand rs (length subs))))
            (values rs (lref subs n))))))

;; replace the node (sub . tail) with (op rs (sub . tail))
(define (edit-sublist lst sub op)
   (if (pair? lst)
      (if (eq? (car lst) sub)
         (op lst)
         (cons (edit-sublist (car lst) sub op)
               (edit-sublist (cdr lst) sub op)))
      lst))

;; todo: define reservoir-sampling-style node selection (1, 2 or n nodes)
;; todo: pass 1, partial parse, pass 2, choose nodes, pass3, search and replace by id
(define (partial-parse lst)
   (let loop ((lst lst) (rout null))
      (if (null? lst)
         (reverse rout)
         (lets ((closep (get usual-delims (car lst) F)))
            (if closep
               (lets ((this lst (grow (cdr lst) closep (list (car lst)))))
                  (if lst
                     (loop lst (cons this rout))
                     (append (reverse rout) this)))
               (loop (cdr lst) (cons (car lst) rout)))))))

(define (flatten node tl)
   (cond
      ((null? node) tl)
      ((pair? node) (flatten (car node) (flatten (cdr node) tl)))
      (else (cons node tl))))

(define (sed-tree-op op)
   (λ (rs)
      (λ (ll)
         (lets
            ((lst (partial-parse (byte-vector->list (car ll))))
             (rs sub (pick-sublist rs lst)) ;; choose partially parsed node to mutate ;; fixme: not checked for F
             (lst (edit-sublist lst sub op)))
            (cons (list->byte-vector (flatten lst null)) (cdr ll)))))) ;; fixme; check for overgrown leaves (or crash with F on output)

;; duplicate a single branch
(define sed-tdup (sed-tree-op (λ (node) (cons (car node) node))))

;; duplicate a branch and whatever comes before the next one (if any)
(define sed-tdup-run 
   (sed-tree-op 
      (λ (node) 
         (cons (car node)
            (let loop ((lst (cdr node)))
               (if (or (null? lst) (pair? (car lst)))
                  node
                  (cons (car lst) (loop (cdr lst)))))))))

;; duplicate a branch and whatever comes before the next one (if any)
;; → swapped lst' (returning the original one if out of data)
(define (swap-next lst node)
   (if (null? lst) 
      (values node lst)
      (lets ((hd lst lst))
         (if (pair? hd) ;; drop here
            (values hd (cons node lst))
            (lets ((node lst (swap-next lst node)))
               (values node (cons hd lst)))))))

;; swap a node with the next one at current level (if any)
(define sed-tswap-level
   (sed-tree-op 
      (λ (node) 
         (lets ((swapd lst (swap-next (cdr node) (car node))))
            (cons swapd lst)))))

(define sed-tdel (sed-tree-op (λ (node) (cdr node))))


;;; sed-surf utils

(define (match-prefix lst p)
   (cond
      ((null? p) True)
      ((null? lst) False)
      ((eq? (car lst) (car p))
         (match-prefix (cdr lst) (cdr p)))
      (else False)))

(define (occurrences lst pat)
   (let loop ((lst lst) (found null) (pos 0))
      (cond
         ((null? lst) found)
         ((match-prefix lst pat)
            (loop (cdr lst) (cons pos found) (+ pos 1)))
         (else
            (loop (cdr lst) found (+ pos 1))))))

(define (add-suffix ff ls)
   (if (null? ls)
      ff
      (lets ((x ls ls))
         (put ff x
            (cons ls (get ff x null))))))

(define (note-substring occurrences rbytes others)
   (let ((score (* (- occurrences 1) (* (- (length rbytes) 1) 2))))
      (if (< score 1)
         others
         (cons (cons score rbytes) others))))

;; → ((score reverse-bytes ..) ...)
(define (radix-walk lsts path n found)
   (cond
      ((null? lsts) found)
      ((null? (cdr lsts)) found)
      ((eq? n 0) found)
      (else
         (ff-fold
            (λ (found char tails)
               (radix-walk tails (cons char path) (- n 1)
                  (note-substring (length tails) (cons char path) found)))
            found
            (fold add-suffix False lsts)))))

;; list of list suffixes
(define (suffixen lst)
   (if (null? lst)
      null
      (cons lst (suffixen (cdr lst)))))

(define (car> a b) (> (car a) (car b)))

;; ((i . x) (j . z) ...) n → z
(define (priority-pick l n)
   (let ((m (caar l)))
      (if (<= n m)
         (cdar l)
         (priority-pick (cdr l) (- n m)))))

;; todo: make surf max jump size a command line flag
(define (frequent-substring rs lst)
   (lets
      ((rs max-depth (rand-range rs 4 20)) ; <- 32 gives a max 100ms search
       (subs (timed "radix-walk" (radix-walk (suffixen lst) null max-depth null)))
       (subs (timed "sorting" (sort car> subs)))
       (rs n (rand rs (fold + 0 (map car subs)))))
      (if (null? subs) ;; <- blank → null
         (values rs null)
         (values rs (reverse (priority-pick subs n))))))

;; poss quaranteed to have >= 2 elems
(define (choose-jump rs poss len)
   (lets
      ((rs poss (random-permutation rs poss))
       (from (car poss))
       (to (cadr poss)))
      (if (= (+ from len) (- to 1)) ;; wouldn't change the data
         (values to from)
         (values from to))))

(define (sed-surf rs) ;; jump between two share suffixes in the block
   (λ (ll)
      (lets
         ((lst (byte-vector->list (car ll)))
          (rs root (frequent-substring rs lst))
          (poss (occurrences lst root)))
         ;; a jump list of one element is constructed for blocks with just one byte
         ;(show "SURF: jumping " (list 'from from 'to to 'using root))
         (if (> (length poss) 1)
            (lets 
               ((from to (choose-jump rs poss (length root)))
                (block (car ll))
                (get (λ (p) (refb block p)))
                (pre (list->byte-vector (map get (iota 0 1 from))))
                (post (list->byte-vector (map get (iota to 1 (sizeb block))))))
               (ilist pre post (cdr ll)))
            ll))))

(define (sed-stut rs) ;; repeat a section
   (λ (ll)
      (lets ((n (sizeb (car ll))))
         (if (< n 4)
            ll
            (lets
               ((rs start (rand-range rs 0 (- n 2)))
                (rs end (rand-range rs (+ start 1) n))
                (pre (map (λ (p) (refb (car ll) p)) (iota 0 1 start)))
                (post (map (λ (p) (refb (car ll) p)) (iota end 1 (sizeb (car ll)))))
                (stut (list->byte-vector (map (λ (p) (refb (car ll) p)) (iota start 1 end))))
                (rs n (rand-log rs 10)) ; max 2^10 = 1024 stuts
                (stuts
                  (fold
                     (λ (tl n) (cons stut tl))
                     (if (null? post)
                        (cdr ll)
                        (cons (list->byte-vector post) (cdr ll)))
                     (iota 0 1 n))))
               (if (null? pre)
                  stuts
                  (cons (list->byte-vector pre) stuts)))))))

(define (sed-dec rs) ;; decrement a byte mod 256
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons 
            (edit-byte-vector (car ll) p 
               (λ (old tl) (if (eq? old 0) 255 (cons (- old 1) tl))))
            (cdr ll)))))

(define (sed-dup rs) ;; duplicate a byte
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons 
            (edit-byte-vector (car ll) p 
               (λ (old tl) (ilist old old tl)))
            (cdr ll)))))

(define (sed-perm rs) ;; permute a few bytes
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons 
            (edit-byte-vector (car ll) p 
               (λ (old tl) 
                  (lets 
                     ((lst (cons old tl))
                      (rs n (rand-range rs 2 20))
                      (head (take lst n))
                      (tail (drop lst n))
                      (rs head (random-permutation rs head)))
                     (append head tail))))
            (cdr ll)))))

;; todo: stub, parse the (or next first valid, if any) code point and edit separately later
(define (sed-utf8-edit rs)
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons 
            (edit-byte-vector (car ll) p 
               (λ (old tl) 
                  ;; assuming we hit a 6-bit ascii char, make it unnecessarily wide
                  (ilist #b11000000 (bor old #b10000000) tl)))
            (cdr ll)))))

;; insert UTF-8 that might be mishandled
(define (sed-utf8-insert rs)
   (λ (ll)
      (lets
         ((rs p (rand rs (sizeb (car ll))))
          (rs bytes (rand-elem rs funny-unicode)))
         (cons
            (edit-byte-vector (car ll) p (λ (old tl) (append bytes (cons old tl))))
            (cdr ll)))))

;; todo: silly boilerplate
; (name . starter), starter : rs paths opts → ((info . func) ...)
(define ll-fuzzers   
   (list
      (rs-fold-node "star" sed-star)
      (rs-fold-node "drop" sed-drop)
      (rs-fold-node "inc" sed-inc)
      (rs-fold-node "dec" sed-dec)
      (rs-fold-node "dup" sed-dup)
      (rs-fold-node "flip" sed-flip)
      (rs-fold-node "stut" sed-stut)
      (rs-fold-node "num" sed-num)
      (rs-fold-node "u8ins" sed-utf8-insert)
      (rs-fold-node "perm" sed-perm)
      (rs-fold-node "surf" sed-surf)
      (rs-fold-node "u8ed" sed-utf8-edit)
      (rs-fold-node "tdup" sed-tdup) ;; duplicate a branch
      (rs-fold-node "tdur" sed-tdup-run) ;; duplicate a branch
      (rs-fold-node "tdel" sed-tdel) ;; delete a branch from the partial parse
      (rs-fold-node "tswal" sed-tswap-level) ;; swap a node with another one at the same level (make arbitrary swap later)
      (cons "crash" 'mr-crasher)))

(define (string->vec str)
   (list->byte-vector (render render str null)))

;;; Stream generators -------------------------------------------------


(define max-block-size (* 2 avg-block-size))

;; bvec|F bvec → bvec
(define (merge head tail)
   (if head
      (list->vector (vec-foldr cons (vec-foldr cons null tail) head))
      tail))

(define (rand-block-size rs)
   (lets ((rs n (rand rs max-block-size)))
      (values rs (max n 8))))

;; todo: might make sense to grow the initial block size limits as 2^n up to final limit
;; stream data from port as desired sized blocks (which are deterministic unlike the sizes we happen to read) and close it at eof
(define (stream-blocks rs port)
   (lets ((rs first (rand-block-size rs)))
      (let loop ((rs rs) (last F) (wanted first)) ;; 0 = block ready (if any)
         (let ((block (interact port wanted)))
            (cond
               ((eof? block) ;; end of stream
                  (if (not (eq? port stdin)) (close-port port))
                  (if last (list last) null))
               ((not block) ;; read error
                  ;; later carp via whatever logging system is used to stderr
                  (if (not (eq? port stdin)) (close-port port))
                  (if last (list last) null))
               ((eq? (sizeb block) (+ wanted 1))
                  ;; a block of required (deterministic) size is ready
                  (lets
                     ((block (merge last block))
                      (rs next (rand-block-size rs)))
                     (pair block (loop rs F next))))
               (else
                  (loop rs (merge last block) (- wanted (sizeb block)))))))))

(define (open-sample-port path)
   (cond
      ((equal? path "-") stdin)
      (else (open-input-file path))))

;; todo: make the first block a special case? <- or grow the block limit
(define (stream-sample rs path)
   (let ((port (open-sample-port path)))
      (if port
         (stream-blocks rs port) ; <- use also for stdin streaming
         (begin
            (mail stderr (foldr renderer '(10) (list "Cannot read '" path "' - acting as if it were blank.")))
            null))))

(define (preread-stdin rs)
   (force (stream-blocks rs stdin)))

;; if n>1 outputs requested and stdin is a sample, preread all of it to memory
(define (maybe-preread-stdin rs paths opts)
   (if (> (get opts 'count F) 1)
      (let ((files (remove (λ (x) (equal? x "-")) paths))) ;; remove all "-"s (there could be many)
         (if (= (length files) (length paths)) 
            files ;; there are no -:s
            (cons (cons "standard-input" (preread-stdin rs)) files)))
      paths))

(define (sample-gen rs paths opts)
   ;; permute once per round
   (lets
      ((paths (maybe-preread-stdin rs paths opts))
       (rs order (random-permutation rs paths)))
      (let loop ((rs rs) (order order))
         (cond
            ((null? order)
               (sample-gen rs paths F)) ;; repermute 
            ((string? (car order)) ;; a path
               (pair
                  (cons
                     (list 'sample (car order)) ;; save sample name to metadata
                     (λ () (stream-sample rs (car order))))
                  (loop (pop-rand rs) (cdr order))))
            (else ;; preread data (when stdin w/ n>1 outputs)
               (pair (car order)
                  (loop rs (cdr order))))))))

(define (repeat thing n)
   (let loop ((n n) (out null))
      (if (eq? n 0)
         out
         (loop (- n 1) (cons thing out)))))

(define (repeat-blocks pre n tail)
   (if (= n 0)
      (list tail)
      (pair pre (repeat-blocks pre (- n 1) tail))))

(define (rand-length rs)
   (lets
      ((rs nbits (rand rs 18))
       (rs n (rand rs (<< 1 (max nbits 6)))))
      (values rs n)))

(define (sgen-flat rs paths opts)
   (let loop ((rs rs))
      (lets
         ((rs base (rand rs 256))
          (rs len (rand-length rs))
          (blocks (div len avg-block-size)))
         (pair
            (cons 
               (list 'flat base len)
               (repeat-blocks
                  (if (> blocks 0)
                     (list->byte-vector (repeat base avg-block-size))
                     'nothing)
                  blocks
                  (list->byte-vector (repeat base (- len (* blocks avg-block-size))))))
            (loop rs)))))

(define (sgen-rrep rs paths opts)
   (let loop ((rs rs))
      (lets
         ((rs nalpha (rand rs 1024)) ;; alphabet size
          (rs letters (random-numbers rs 256 nalpha)) ;; alphabet (may have repetition)
          (alpha (list->vector letters)) ;; index 0-(nalpha-1)
          (rs len (rand-log rs 10)) ;; block size to repeat
          (rs poss (random-numbers rs nalpha len))
          (bytes (map (λ (p) (vec-ref alpha p)) poss))
          (block (list->byte-vector bytes))
          (rs n (rand-log rs 6))) ;; repeat block how many times
         (pair
            (cons 'rrep (map (λ (p) block) (iota 0 1 n)))
            (loop rs)))))

(define (random-bytes rs n out)
   (cond
      ((eq? n 0)
         (values rs out))
      ((eq? n 1) ;; get 8 bits
         (lets ((rs b (rand rs 256)))
            (random-bytes rs 0 (cons b out))))
      (else ;; get and split 16  bits
         (lets ((digit rs (uncons rs F)))
            (random-bytes rs (- n 2)
               (ilist (band digit 255) (>> digit 8) out))))))

(define (sgen-random rs paths opts)
   (let loop ((rs rs))
      (lets 
         ((rs len (rand rs 4096))
          (rs bytes (random-bytes rs len null)))
         (pair
            (cons 'random (list (list->byte-vector bytes))) ;; <- could also stream this
            (loop rs)))))

(define ll-generators
   (list
      (cons "sample" sample-gen)   ;; stream data from samples
      (cons "flat" sgen-flat)      ;; repeat a single value
      (cons "random" sgen-random)  ;; genrate random data (radamsa -n 100000000000000 -f flip -g random --single | pv | dieharder -g 200 -a)
      (cons "rrep" sgen-rrep)))

;;; Stream polymerasen ------------------------------------------------

;; todo: once-dec could also also take a cont
;; run mutafn with prob 1/(ip+n) to block at offset n, or last if out of data

(define (once-dec rs mutafn ll)
   (lets 
      ((hd ll (uncons ll F))
       (rs ip (rand rs 32)))
      (if hd
         (let loop ((rs rs) (ll ll) (last hd) (ip ip))
            (lets ((rs n (rand rs ip)))
               (if (eq? n 0)
                  (mutafn (cons last ll))
                  (lets ((next ll (uncons ll F)))
                     (if next
                        (cons last 
                           (loop rs ll next (+ ip 1)))
                        (mutafn (list last)))))))
         ll)))

(define ll-polymerase 
   (list
      (rs-fold-node "onced"
         (λ (rs) (λ (mutagen ll) (once-dec rs mutagen ll))))))

;;; Muxers --------------------------------------------------------------

(define (bigger-first a b)
   (lets ((sa (sizeb a)) (sb (sizeb b)))
      (if (< sa sb)
         (values b sb a sa)
         (values a sa b sb))))

(define (zip-blocks op all bll)
   (cond
      ((null? all) (values all bll))
      ((null? bll) (values all bll))
      ((pair? all)
         (if (pair? bll)
            (lets 
               ((a as b bs (bigger-first (car all) (car bll)))
                (al (byte-vector->list a))
                (bl (byte-vector->list b))
                (merged (list->byte-vector (zip op al bl)))) ;; will cut tail of al
               (values
                  (if (eq? al bl) ;; unless the tail is a lie
                     (cons merged (cdr all))
                     (ilist merged
                        (list->byte-vector (map (λ (p) (refb a p)) (iota bs 1 as)))
                        (cdr all)))
                  bll))
            (zip-blocks op all (bll))))
      (else 
         (zip-blocks op (all) bll))))

(define ll-muxers ;; todo: many to be added in 0.2.1
   (list
      (cons "swap" ;; swap streams
         (λ (rs paths opts)
            (simple-node "swap"
               (λ (a b) (values b a)))))
      (cons "cat" ;; catenate streams
         (λ (rs paths opts)
            (simple-node "cat"
               (λ (a b) (values (lappend a b) null)))))
      (cons "min" ;; get minimum for a block
         (λ (rs paths opts)
            (simple-node "min"
               (λ (a b) 
                  (zip-blocks min a b)))))
      (cons "max" ;; get minimum for a block
         (λ (rs paths opts)
            (simple-node "max"
               (λ (a b) (zip-blocks max a b)))))
      (cons "avg"
         (λ (rs paths opts)
            (simple-node "avg"
               (λ (a b) (zip-blocks (λ (a b) (>> (+ a b) 1)) a b)))))))

;; mux-step - walk the two lazy streams (whose length we don't know) and apply muxer once 
;; at some position, and then pass control to cont. blocks of a are emitted as output and 
;; b is dropped, speeds being roughly equivalent.

; → (cont ll ll)
(define (mux-step rs all bll muxer ip cont)
   (define (finish as bs)
      (cond
         ((null? as) (cont null bs))
         ((null? bs) (cont as null))
         (else 
            (lets ((as bs (muxer as bs))) 
               (cont as bs)))))
   (lets 
      ((a as (uncons all F))
       (b bs (uncons bll F)))
      (cond
         ((not a) (finish all bll)) ;; no base stream to mux
         ((not b) (finish all bll)) ;; no data to mux against
         (else
            (let loop ((rs rs) (a a) (as as) (b b) (bs bs))
               (lets ((rs n (rand rs ip)))
                  (if (eq? n 0)
                     (finish (cons a as) (cons b bs))
                     (lets ((rs n (rand rs 2)))
                        (if (eq? n 0)
                           (lets ((aa as (uncons as F)))
                              (if aa
                                 (pair a (loop rs aa as b bs)) ;; more a follows, emit and continue
                                 (finish (list a) (cons b bs)))) ;; out of a
                           (lets ((bb bs (uncons bs F)))
                              (if bb
                                 (loop rs a as bb bs) ;; more b follows, drop b an continue
                                 (loop rs a as b null)))))))))))) ;; out of b, keep last block

(define (fast-forward ll)
   (cond
      ((pair? ll) (fast-forward (cdr ll)))
      ((null? ll) ll)
      (else (fast-forward (ll)))))

(define (mux-once rs all bll muxer ip)
   (mux-step rs all bll muxer ip 
      (λ (a b) 
         (fast-forward b)   ;; read the b stream to be dropped in order to close the fd
         a)))

(define ll-muxer-polymerase 
   (list
      (rs-fold-node "once" 
         (λ (rs)
            (λ (muxer all bll)
               (lets
                  ((rs bits (rand rs 8))
                   (rs ip (rand rs (<< 1 bits)))) ;; inverse probability
                  (mux-once rs all bll muxer ip)))))))

;;; Master polymerase --------------------------------------------------------------

;; grab n streams (1 + one more with 1/3n prob)
(define (choose-streams rs gens)
   (let loop ((rs rs) (gens gens) (taken null))
      (lets ((rs n (rand rs (* 3 (length taken)))))
         (if (eq? n 0)
            (lets ((this gens (uncons gens F)))
               (loop rs gens (cons this taken)))
            (values rs gens taken)))))

(define (plain-sample? node) 
   (and (pair? (car node))
      (eq? (caar node) 'sample)))

;; merger many data streams to one using the fuzzers and muxers
(define (master-merge rs muxs fuzs lls)
   (lets ((rs n (rand rs 5)))
      (cond
         ((eq? n 0) ;; permute
            (lets ((rs lls (random-permutation rs lls)))
               (master-merge rs muxs fuzs lls)))
         ((eq? n 1) ;; add a stream fuzzer to first
            (lets ((fuzz fuzs (uncons fuzs F)))
               (master-merge rs muxs fuzs 
                  (cons (fuzz (car lls)) (cdr lls)))))
         ((eq? n 2) ;; merge two streams (if more than one)
            (if (not (null? (cdr lls)))
               (lets 
                  ((mux muxs (uncons muxs F))
                   (a (car lls)) (b (cadr lls)))
                  (master-merge rs muxs fuzs
                     (cons (mux a b) (cddr lls))))
               (master-merge rs muxs fuzs lls)))
         ((and (null? (cdr lls)) (not (plain-sample? (car lls)))) ;; else try exit
            (values rs muxs fuzs (car lls)))
         (else ;; else keep muxin
            (master-merge rs muxs fuzs lls)))))

(define (master-polymerase rs gens muxs fuzs)
   (lets
      ((rs gens tomux (choose-streams rs gens)) ;; choose some streams to use
       (rs muxs fuzs node (master-merge rs muxs fuzs tomux))) ;; combine them to one stream
      (pair node  ;; <- data to generate
         (master-polymerase rs gens muxs fuzs))))

;; a single-stream variant for testing stream fuzzers
(define (master-polymerase/single-stream rs gens muxs fuzs)
   (lets
      ((this gens (uncons gens F))
       (rs muxs fuzs node (master-merge rs muxs fuzs (list this))))
      (pair node  ;; <- data to generate
         (master-polymerase/single-stream rs gens muxs fuzs))))

; node : rs paths opts → ((info . value) ...)

(define max-seed #x1000000000000)

(define (pop-at opts n) ; (... (pri . ((info . val) ...)) ...) n → matching (info . val) x (... (pri . ...) ...)
   (lets
      ((node (car opts))
       (pri ll node))
      (if (< n pri)
         (lets ((next ll (uncons ll F)))
            (values next (cons (cons pri ll) (cdr opts))))
         (lets ((grabbed opts (pop-at (cdr opts) (- n pri))))
            (values grabbed (cons node opts))))))

(define (mux rs opts lim)
   (lets 
      ((rs n (rand rs lim))
       (val opts (pop-at opts n)))
      (pair val (mux rs opts lim))))

;; mux streams probabilistically according to priorities
(define (make-muxer rs opts)
   (if (null? (cdr opts))
      (values rs (cdar opts)) ;; no need to mux
      (lets
         ((rs seed (rand rs max-seed))
          (opts (sort car> opts))
          (total (fold + 0 (map car opts))))
         (values rs (mux (seed->rands seed) opts total)))))

(define (find-module mods name)
   (cond
      ((null? mods) F)
      ((equal? (caar mods) name) (cdar mods))
      (else (find-module (cdr mods) name))))

;; start node streams, each with their own rs, and mux them according to priorities
; → rs' ((info . val) ...)
(define (start rs mods pris paths opts)
   (let loop ((rs rs) (pris pris) (out null))
      (cond
         ((null? pris)
            (make-muxer rs out))
         ((find-module mods (cdar pris)) =>
            (λ (modfn)
               (lets 
                  ((rs seed (rand rs max-seed))
                   (nodes (modfn (seed->rands seed) paths opts)))
                  (loop rs (cdr pris) (cons (cons (caar pris) nodes) out)))))
         (else
            (if (not (equal? (cdar pris) "help"))
               (show "I don't have a module called " (cdar pris))) 
            (error "Valid options are " (map car mods))))))

;; merge muxer polymerase stream and muxer stream to a stream muxer stream
(define (muxer-stream pols muxs)
   (lets
      ((pol pols (uncons pols F))
       (mux muxs (uncons muxs F)))
      (pair
         (λ (aln bln)
            (lets
               ((a-info a-data aln)
                (b-info b-data bln))
               (cons
                  (list (car pol) (car mux) a-info b-info) ;; (pattern muxer str-a str-b)
                  (λ () ((cdr pol) (cdr mux) a-data b-data)))))
         (muxer-stream pols muxs))))

;; ditto, but for stream muxers which take just one stream as argument
(define (fuzzer-stream pols fuzs)
   (lets
      ((pol pols (uncons pols F))
       (fuz fuzs (uncons fuzs F)))
      (pair
         (λ (aln)
            (lets ((a-info a-data aln))
               (cons
                  (list (car pol) (car fuz) a-info) ;; (pattern muxer str-a)
                  (λ () ((cdr pol) (cdr fuz) a-data)))))
         (fuzzer-stream pols fuzs))))

(define (force-n ll n)
   (if (> n 0)
      (lets ((this ll (uncons ll F)))
         (this)
         (force-n ll (- n 1)))))
     
(define examples 
"Typical usage:
   Fuzz file.foo to fuzzed.foo
      $ cat file.foo | radamsa > fuzzed.foo

   Same but with explicitly given paths
      $ radamsa -o /tmp/fuzzed.foo file.foo

   Same but make 10 files
      $ radamsa -n 10 -o /tmp/fuzzed-%n.foo file.foo

   Same but use multiple samples from foo-files/*.foo
      $ radamsa -n 10 -o /tmp/fuzzed-%n.foo foo-files/*.foo")

(define (start-radamsa opts paths)
   (call/cc
      (λ (ret)
         (let ((fail (λ (why rval) (print why) (ret rval))))
            (cond
               ((get opts 'help F) (print-usage-text F) 0)
               ((get opts 'advanced F) (print-usage-text T) 0)
               ((get opts 'examples F) (print examples) 0)
               ((get opts 'version F)
                  (print version-str)
                  0)
               ((not (get opts 'seed F))
                  ;; make a time-based seed unless one is given explicitly
                  (start-radamsa (add-seed opts) paths))
               (else
                  (lets
                     ((f-pris  (split-priorities (get opts 'fuzzers F) opts paths fail))
                      (g-pris  (split-priorities (get opts 'generators F) opts paths fail))
                      (p-pris  (split-priorities (get opts 'polymerase F) opts paths fail))
                      (m-pris  (split-priorities (get opts 'muxers F) opts paths fail))
                      (mp-pris (split-priorities (get opts 'muxer-polymerase F) opts paths fail))
                      (seed (string->seed (get opts 'seed F)))
                      (n (get opts 'count F))
                      (paths ;; add stdin as a sample if no files given and no blank requested
                        (if (and (null? paths) (not (get opts 'blank F)) (not (null? (keep (λ (x) (equal? (cdr x) "sample")) g-pris)))) ; <- eww
                           '("-") paths))
                      ;; todo: map sample source generator to samples
                      (have-stdin? (mem equal? paths "-"))
                      (rs (seed->rands seed))
                      (rs gens (start rs ll-generators g-pris paths opts))
                      (rs fuzs (start rs ll-fuzzers f-pris paths opts))
                      (rs pols (start rs ll-polymerase p-pris paths opts))
                      (fuzs (fuzzer-stream pols fuzs)) ;; fuse available polymerase with stream fuzzers
                      (rs muxs (start rs ll-muxers m-pris paths opts))
                      (rs mpol (start rs ll-muxer-polymerase mp-pris paths opts))
                      (muxs (muxer-stream mpol muxs)) ;; fuze available muxer polymerase with muxers
                      (master 
                        (if (or (get opts 'single F) have-stdin?)
                           master-polymerase/single-stream
                           master-polymerase))
                      (lls (master rs gens muxs fuzs))
                      (record-meta (if (get opts 'verbose F) record-meta/stderr record-meta/not))
                      (thunks ;; (thunk ...), calling causes io 
                        (lzip (λ (a b) (λ () (wait 100) (a b record-meta))) ;; <- wait in order to allow some time to write
                           (get opts 'output F)
                           lls))
                      (thunks (drop thunks (get opts 'seek 0))) ;; fast forward if --seek
                      )
                     (force-n thunks n)
                     0)))))))

(define (toy-meta)
   (bind (wait-mail)
      (λ (from msg)
         (mail from 'anon)
         (toy-meta))))

(define (bummer)
   (lets
      ((s "        ") (a " *    *    *")
       (n (list->string (list 10)))
       (b "   *  *  *") (c "* * BOOOM *  *"))
      (mail stdout (list 27 35 55 27 91 53 109))
      (print 
         (foldr string-append "" 
            (list n n s a n s b n s c n s b n s a n)))
      (mail stdout (list 27 91 48 109 10))))

(define apology 
   '("Radamsa stopped because something bad was about to happen. Sorry."
     "If you want to help fix this, drop by at #radamsa on freenode, file"
     "a bug at http://code.google.com/p/ouspg/issues/entry or send email to"
     "aki.helin@ee.oulu.fi. Adding the following text and possibly"
     "instructions to reproduce this crash will help."))

;; todo: cut down a and b representation length if they are too large
(define (boom err-code a b)
   (bummer)
   (for-each print apology)
   (show "Info: " (list err-code 'a a 'b b)))

(λ (args)
   (fork-server 'meta toy-meta)
   (fork-linked-server 'radamsa
      (λ () (process-arguments (cdr args) command-line-rules usage-text start-radamsa)))
   (let ((res (wait-mail)))
      (exit-owl
         (tuple-case res
            ((radamsa msg)
               (tuple-case msg
                  ((finished rval x t) rval)
                  ((error cont msg reason) (show msg reason) 1)
                  ((crashed err-code a b) (boom err-code a b) 127)
                  (else (show "Abnormal exit: " res) 2)))
            (else
               (print "Abnormal condition.")
               3)))))

