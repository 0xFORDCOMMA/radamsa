;;;
;;; Radamsa - a general purpose test data fuzzer
;;;

;; todo: muxers could return F when can't do anything, so that the meta could be removed
;; todo: node infos should be ffs of static values like name, description etc to allow something like $ radamsa --list-modules
;; todo: module startup should use (name-of node) instead of a separate string in the list
;; maybe: if the case stream would use for example seeds generated by a lagged fibonacci generator, one could seek in O(log n)
;;         ^ might make sense to thread the random state differently in this case

;; todo: stream muxer: cat a b → a ++ b, seen some bugs that needed this

(define rval-failed-to-start-modules 1)
(define rval-crashed 127) ;; in-owl thread crash after detecting an error

(define (renderer val tl)
   (render render val tl))

(define (car> a b) (> (car a) (car b)))

(define (get-stdout-fd n)
   (pair 
      (cons
         (list->string (foldr (λ (x tl) (render render x tl)) null '(list "stdout-" n)))
         stdout)
      (get-stdout-fd (+ n 1))))

;; force and send a stream to a port
(define (mail-blocks str port n)
   (cond
      ((pair? str)
         (lets
            ((block str str)
             (size (sizeb block)))
            (if (not (eq? size 0))
               (mail port block))
            (mail-blocks str port (+ n size))))
      ((null? str) n)
      (else (mail-blocks (str) port n))))

(define (send-stream data port)
   (let ((res (mail-blocks data port 0)))
      ((if (eq? port stdout) flush-port close-port) port)
      res))

(define (writer fds lls record-meta n)
   (let loop ((lls lls) (fds fds) (n n))
      (if (= n 0)
         (values lls fds)
         (lets 
            ((out fds (uncons fds F))
             (name fd out) ;; where to write, name = path, ip etc
             (node lls (uncons lls F)) ;; what to write
             (info data node))
            (if (not fd)
               (error "Failed to write: " name))
            (let ((written (send-stream data fd)))
               (record-meta info written)
               (loop lls fds (- n 1)))))))

(define (record-meta/stdout info len)
   ;(print* (list " → " info ": " len))
   42
)

(import lib-args)

(define command-line-rule-exp
   `((help "-h" "--help")
     (output "-o" "--output" has-arg default "-"
         comment "Where to write the generated data?")
     (count "-n" "--count" cook ,string->integer check ,(λ (x) (> x 0))
         default "1" comment "How many outputs to generate?")
     (seed "-s" "--seed" has-arg comment "Random seed (any string). Default random.")
     (fuzzers "-f" "--fuzzers" has-arg default "star" 
         comment "Which stream fuzzers to run? (pass help to list options)")
     (generators "-g" "--generators" has-arg default "blank" 
         comment "Which stream generators to run? (pass help to list options)")
     (polymerase "-p" "--polymerase" has-arg default "od" 
         comment "Which stream mutator patterns to use? (pass help to list options)")
     (muxer-polymerase "-P" "--muxer-polymerase" has-arg default "once" 
         comment "Which muxer mutator patterns to use? (pass help to list options)")
     (muxers "-m" "--muxers" has-arg default "swap" 
         comment "Which stream muxers to use? (pass help to list options)")
     (seek "-S" "--seek" has-arg cook ,string->integer check ,(λ (x) (> x 0))
         comment "Skip start from nth file.")
     (single F "--single" comment "Do not mux")
     (blank "-T" "--tabula-rasa" comment "Do not read any sample data.")))

(define command-line-rules
   (cl-rules command-line-rule-exp))

(define usage-text "Usage: radamsa [option] [sample-path] ...")

(define (print-usage-text)
   (print usage-text)
   (print-rules command-line-rules))

;; () → string
(define (urandom-seed)
   (let ((fd (open-input-file "/dev/urandom"))) ;; False if not there
      (if fd
         (let ((data (interact fd 8)))
            (close-port fd)
            (if (vector? data)
               (list->string
                  (render render (fold (λ (n d) (+ d (<< n 8))) 0 data) null))
               False))
         False)))

;; () → string (decimal number)
(define (time-seed)
   (list->string (render render (time-ms) null)))

;; get a seed if none was given explicitly (use /dev/urandom or current time in ms)
(define (add-seed opts)
   (put opts 'seed
      (or (urandom-seed) (time-seed))))

;; str → integer
(define (string->seed str)
   (if (string? str)
      (fold (λ (seed digit) (* (+ digit 1) (+ seed 1))) 1 (str-iter str))
      (error "bad seed: " str)))

;; str → str | (name . priority)
(define (try-split-priority str)
   (lets ((parts (c/=/ str)))
      (cond
         ((= (length parts) 1)
            ;; no priority given. default to 1 (lowest).
            (cons 1 (car parts)))
         ((= (length parts) 2)
            (let ((pri (string->integer (cadr parts))))
               (if (and pri (> pri 0))
                  (cons pri (car parts))
                  str)))
         (else str))))

;; later: all-fu*-cut

(define (enable-modules selection opts paths fail)
   (lets
      ((mods (keep (λ (x) (> (string-length x) 0)) (c/,/ selection))) ;; split
       (pris (map try-split-priority mods))
       (bads (keep string? pris)))
      (if (null? bads)
         pris
         (begin
            (for-each (λ (x) (show "Bad module selection: " x)) bads)
            (print "Modules selection is a comma-separated list of module names optionally followed by weights.")
            (print "For example -e foo,bar,baz=2 will use baz about as often as foo and bar combined.")
            (print "Use $ radamsa -e help to list options")
            (fail False)))))

(define (iterate thing)
   (pair thing (iterate thing)))

;; iterate the same thing
(define (simple-node name value)
   (let ((node (cons name value)))
      (iterate node)))

;; iterate the same thing carrying rs
(define (rs-fold-node rs name value)
   (pair (cons name (value rs))
      (lets ((digit rs (uncons rs F)))
         (rs-fold-node rs name value))))

;;; Stream fuzzers -----------------------------------------------------------

(define (byte-vector->list bvec)
   (let ((n (sizeb bvec)))
      (if (eq? n 0)
         null
         (let loop ((pos (- n 1)) (out null))
            (cond
               ((eq? pos 0)
                  (cons (refb bvec pos) out))
               (else
                  (lets ((posp _ (fx- pos 1)))
                     (loop posp (cons (refb bvec pos) out)))))))))

;; a silly fixnum/primitive mess, since this is fairly commonly used
(define (edit-byte-vector bvec edit-pos fn)
   (let ((len (sizeb bvec)))
      (if (eq? len 0)
         bvec
         (let loop ((pos (- len 1)) (out null))
            (let ((val (refb bvec pos)))
               (if (eq? pos edit-pos)
                  (if (eq? pos 0)
                     (list->byte-vector (fn val out))
                     (lets ((pos _ (fx- pos 1)))
                        (loop pos (fn val out))))
                  (if (eq? pos 0)
                     (list->byte-vector (cons val out))
                     (lets ((pos _ (fx- pos 1)))
                        (loop pos (cons val out))))))))))

(define (sed-star rs)
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons
            (edit-byte-vector (car ll) p (λ (old tl) (cons 42 tl)))
            (cdr ll)))))

; (name . starter), starter : rs paths opts → ((info . func) ...)
(define ll-fuzzers   
   (list
      (cons "star"
         (λ (rs paths opts)
            (print "Fuzzer foo started.")
            (rs-fold-node rs "star" sed-star)))))

(define (string->vec str)
   (list->byte-vector (render render str null)))

;;; Stream generators -------------------------------------------------

(define avg-block-size 4096)
(define max-block-size (* 2 avg-block-size))

;; bvec|F bvec → bvec
(define (merge head tail)
   (if head
      (list->vector (vec-foldr cons (vec-foldr cons null tail) head))
      tail))

(define (rand-block-size rs)
   (lets ((rs n (rand rs max-block-size)))
      (values rs (max n 8))))

;; todo: might make sense to grow the initial block size limits as 2^n up to final limit
;; stream data from port as desired sized blocks (which are deterministic unlike the sizes we happen to read) and close it at eof
(define (stream-blocks rs port)
   (lets ((rs first (rand-block-size rs)))
      (let loop ((rs rs) (last F) (wanted first)) ;; 0 = block ready (if any)
         (let ((block (interact port wanted)))
            (cond
               ((eof? block) ;; end of stream
                  (if (not (eq? port stdin)) (close-port port))
                  (if last (list last) null))
               ((not block) ;; read error
                  ;; later carp via whatever logging system is used to stderr
                  (if (not (eq? port stdin)) (close-port port))
                  (if last (list last) null))
               ((eq? (sizeb block) (+ wanted 1))
                  ;; a block of required (deterministic) size is ready
                  (lets
                     ((block (merge last block))
                      (rs next (rand-block-size rs)))
                     (pair block (loop rs F next))))
               (else
                  (loop rs (merge last block) (- wanted (sizeb block)))))))))

(define (open-sample-port path)
   (cond
      ((equal? path "-") stdin)
      (else (open-input-file path))))

(define (pop-rand rs)
   (lets ((digit rs (uncons rs F))) rs))

;; todo: make the first block a special case?
(define (stream-sample rs path)
   (let ((port (open-sample-port path)))
      (if port
         (stream-blocks rs port) ; <- use also for stdin streaming
         (error "Failed to read " path))))

;; todo: switch to stream mode if no samples given?
(define (sample-gen rs paths opts)
   ;; permute once per round
   (lets ((rs order (random-permutation rs paths)))
      (let loop ((rs rs) (order order))
         (if (null? order)
            (sample-gen rs paths F) ;; repermute 
            (pair
               (cons
                  (list 'sample (car order)) ;; save sample name to metadata
                  (λ () (stream-sample rs (car order))))
               (loop (pop-rand rs) (cdr order)))))))

(define ll-generators
   (list
      (cons "blank"
         (λ (rs paths opts)
            (print "Generator xs started.")
            (let ((s (string->vec "......")))
               (simple-node "xs" 
                  (map (λ (x) s) (iota 0 1 30))))))
      (cons "sample" sample-gen)))

;;; Stream polymerases ------------------------------------------------

;; todo: once-dec could also also take a cont
;; run mutafn with prob 1/(ip+n) to block at offset n, or last if out of data

(define (once-dec rs mutafn ll)
   (lets 
      ((hd ll (uncons ll F))
       (rs ip (rand rs 32)))
      (if hd
         (let loop ((rs rs) (ll ll) (last hd) (ip ip))
            (lets ((rs n (rand rs ip)))
               (if (eq? n 0)
                  (mutafn (cons last ll))
                  (lets ((next ll (uncons ll F)))
                     (if next
                        (cons last 
                           (loop rs ll next (+ ip 1)))
                        (mutafn (list last)))))))
         ll)))

(define ll-polymerase 
   (list
      (cons "od" ;; mutate Once with Decrementing probability
         (λ (rs paths opts)
            (print "Poly OD started.")
            (rs-fold-node rs "once-dec" 
               (λ (rs) (λ (mutagen ll) (once-dec rs mutagen ll))))))))

;;; Muxers --------------------------------------------------------------

;         active  active
;         v       v
; muxer : ll ll → ll ll, input and output non-null

(define ll-muxers
   (list
      (cons "swap" ;; Simply swap streams
         (λ (rs paths opts)
            (print "Unit muxer started")
            (simple-node "swap"
               (λ (a b) (values b a)))))))

;; mux-step - walk the two lazy streams (whose length we don't know) and apply muxer once 
;; at some position, and then pass control to cont. blocks of a are emitted as output and 
;; b is dropped, speeds being roughly equivalent.

; → (cont ll ll)
(define (mux-step rs all bll muxer ip cont)
   (define (finish as bs)
      (cond
         ((null? as) (cont null bs))
         ((null? bs) (cont as null))
         (else 
            (lets ((as bs (muxer as bs))) 
               (cont as bs)))))
   (lets 
      ((a as (uncons all F))
       (b bs (uncons bll F)))
      (cond
         ((not a) (finish all bll)) ;; no base stream to mux
         ((not b) (finish all bll)) ;; no data to mux against
         (else
            (let loop ((rs rs) (a a) (as as) (b b) (bs bs))
               (lets ((rs n (rand rs ip)))
                  (if (eq? n 0)
                     (finish (cons a as) (cons b bs))
                     (lets ((rs n (rand rs 2)))
                        (if (eq? n 0)
                           (lets ((aa as (uncons as F)))
                              (if aa
                                 (pair a (loop rs aa as b bs)) ;; more a follows, emit and continue
                                 (finish (list a) (cons b bs)))) ;; out of a
                           (lets ((bb bs (uncons bs F)))
                              (if bb
                                 (loop rs a as bb bs) ;; more b follows, drop b an continue
                                 (loop rs a as b null)))))))))))) ;; out of b, keep last block

(define (mux-once rs all bll muxer ip)
   (mux-step rs all bll muxer ip (λ (a b) a)))

(define ll-muxer-polymerase 
   (list
      (cons "once"
         (λ (rs paths opts)
            (print "Muxer polymerase once started.")
            (rs-fold-node rs "once" 
               (λ (rs)
                  (λ (muxer all bll)
                     (lets
                        ((rs bits (rand rs 8))
                         (rs ip (rand rs (<< 1 bits)))) ;; inverse probability
                        (mux-once rs all bll muxer ip)))))))))


;; master polymerase controls how many streams we'll use, and chooses how to mux n fuzz them together

;; grab some streams 
(define (choose-streams rs gens)
   (let loop ((rs rs) (gens gens) (taken null))
      (lets ((rs n (rand rs (* 3 (length taken)))))
         (if (eq? n 0)
            (lets ((this gens (uncons gens F)))
               (loop rs gens (cons this taken)))
            (values rs gens taken)))))

(define (plain-sample? node) 
   (and (pair? (car node))
      (eq? (caar node) 'sample)))

;; merger many data streams to one using the fuzzers and muxers
(define (master-merge rs muxs fuzs lls)
   (lets ((rs n (rand rs 5)))
      (cond
         ((eq? n 0) ;; permute
            (lets ((rs lls (random-permutation rs lls)))
               (master-merge rs muxs fuzs lls)))
         ((eq? n 1) ;; add a stream fuzzer to first
            (lets ((fuzz fuzs (uncons fuzs F)))
               (master-merge rs muxs fuzs (cons (fuzz (car lls)) (cdr lls)))))
         ((eq? n 2) ;; merge two streams (if more than one)
            (if (not (null? (cdr lls)))
               (lets 
                  ((mux muxs (uncons muxs F))
                   (a (car lls)) (b (cadr lls)))
                  (master-merge rs muxs fuzs
                     (cons (mux a b) (cddr lls))))
               (master-merge rs muxs fuzs lls)))
         ((and (null? (cdr lls)) (not (plain-sample? (car lls)))) ;; else try exit
            (values rs muxs fuzs (car lls)))
         (else ;; else keep muxin
            (master-merge rs muxs fuzs lls)))))

;; todo: needs to act differently if only one sample which is stdin, so some special handling will be needed
(define (master-polymerase rs gens muxs fuzs)
   (lets
      ((rs gens tomux (choose-streams rs gens)) ;; choose some streams to use
       (rs muxs fuzs node (master-merge rs muxs fuzs tomux))) ;; combine them to one stream
      (pair node  ;; <- data to generate
         (master-polymerase rs gens muxs fuzs))))

;; a single-stream variant for testing stream fuzzers
(define (master-polymerase/single-stream rs gens muxs fuzs)
   (lets
      ((this gens (uncons gens F))
       (rs muxs fuzs node (master-merge rs muxs fuzs (list this))))
      (pair node  ;; <- data to generate
         (master-polymerase/single-stream rs gens muxs fuzs))))

; node : rs paths opts → ((info . value) ...)

(define max-seed #x1000000000000)

(define (pop-at opts n) ; (... (pri . ((info . val) ...)) ...) n → matching (info . val) x (... (pri . ...) ...)
   (lets
      ((node (car opts))
       (pri ll node))
      (if (< n pri)
         (lets ((next ll (uncons ll F)))
            (values next (cons (cons pri ll) (cdr opts))))
         (lets ((grabbed opts (pop-at (cdr opts) (- n pri))))
            (values grabbed (cons node opts))))))

(define (mux rs opts lim)
   (lets 
      ((rs n (rand rs lim))
       (val opts (pop-at opts n)))
      (pair val (mux rs opts lim))))

;; mux streams probabilistically according to priorities
(define (make-muxer rs opts)
   (if (null? (cdr opts))
      (values rs (cdar opts)) ;; no need to mux
      (lets
         ((rs seed (rand rs max-seed))
          (opts (sort car> opts))
          (total (fold + 0 (map car opts))))
         (values rs (mux (seed->rands seed) opts total)))))

(define (find-module mods name)
   (cond
      ((null? mods) F)
      ((equal? (caar mods) name) (cdar mods))
      (else (find-module (cdr mods) name))))

;; start node streams, each with their own rs, and mux them according to priorities
; → rs' ((info . val) ...)
(define (start rs mods pris paths opts)
   (let loop ((rs rs) (pris pris) (out null))
      (cond
         ((null? pris)
            (make-muxer rs out))
         ((find-module mods (cdar pris)) =>
            (λ (modfn)
               (lets 
                  ((rs seed (rand rs max-seed))
                   (nodes (modfn (seed->rands seed) paths opts)))
                  (loop rs (cdr pris) (cons (cons (caar pris) nodes) out)))))
         (else
            (error "I don't have a module called " (caar pris))))))

;; merge muxer polymerase stream and muxer stream to a stream muxer stream
(define (muxer-stream pols muxs)
   (lets
      ((pol pols (uncons pols F))
       (mux muxs (uncons muxs F)))
      (pair
         (λ (aln bln)
            (lets
               ((a-info a-data aln)
                (b-info b-data bln))
               (cons
                  (list (car pol) (car mux) a-info b-info) ;; (pattern muxer str-a str-b)
                  ((cdr pol) (cdr mux) a-data b-data))))
         (muxer-stream pols muxs))))

;; ditto, but for stream muxers which take just one stream as argument
(define (fuzzer-stream pols fuzs)
   (lets
      ((pol pols (uncons pols F))
       (fuz fuzs (uncons fuzs F)))
      (pair
         (λ (aln)
            (lets ((a-info a-data aln))
               (cons
                  (list (car pol) (car fuz) a-info) ;; (pattern muxer str-a)
                  ((cdr pol) (cdr fuz) a-data)))) ;; <- be lazy
         (fuzzer-stream pols fuzs))))

(define (start-radamsa opts paths)
   (call/cc
      (λ (ret)
         (let ((fail (λ (why rval) (print why) (ret rval))))
            (cond
               ((get opts 'help F)
                  (print-usage-text)
                  0)
               ((not (get opts 'seed F))
                  ;; make a time-based seed unless one is given explicitly
                  (start-radamsa (add-seed opts) paths))
               (else
                  (show "opts: " opts)
                  (lets
                     ((f-pris  (enable-modules (get opts 'fuzzers F) opts paths fail))
                      (g-pris  (enable-modules (get opts 'generators F) opts paths fail))
                      (p-pris  (enable-modules (get opts 'polymerase F) opts paths fail))
                      (m-pris  (enable-modules (get opts 'muxers F) opts paths fail))
                      (mp-pris (enable-modules (get opts 'muxer-polymerase F) opts paths fail))
                      (seed (string->seed (get opts 'seed F)))
                      (paths ;; add stdin as a sample if no files given and no blank requested
                        (if (and (null? paths) (not (get opts 'blank F)))
                           '("-") paths))
                      (rs (seed->rands seed))
                      (offset (get opts 'seek 0))
                      (rs gens (start rs ll-generators g-pris paths opts))
                      (rs fuzs (start rs ll-fuzzers f-pris paths opts))
                      (rs pols (start rs ll-polymerase p-pris paths opts))
                      (fuzs (fuzzer-stream pols fuzs)) ;; fuse available polymerase with stream fuzzers
                      (rs muxs (start rs ll-muxers m-pris paths opts))
                      (rs mpol (start rs ll-muxer-polymerase mp-pris paths opts))
                      (muxs (muxer-stream mpol muxs)) ;; fuze available muxer polymerase with muxers
                      (master 
                        (if (get opts 'single F)
                           master-polymerase/single-stream
                           master-polymerase))
                      (lls (drop (master rs gens muxs fuzs) offset)) ;; <- would be nicer to zip also lls and fds together and fast forward
                      (fds (drop (get-stdout-fd 0) offset))
                      (n (get opts 'count F))
                      (lls fds (writer fds lls record-meta/stdout n)))
                     0)))))))

(define (toy-meta)
   (bind (wait-mail)
      (λ (from msg)
         (mail from 'anon)
         (toy-meta))))

(λ (args)
   (fork-server 'meta toy-meta)
   (fork-linked-server 'radamsa
      (λ () (process-arguments (cdr args) command-line-rules usage-text start-radamsa)))
   (let ((res (wait-mail)))
      (exit-owl
         (tuple-case res
            ((radamsa msg)
               (if (and (tuple? msg) (eq? 'finished (ref msg 1)))
                  (ref msg 2) ;; normal radamsa thread exit, return the exit value
                  (begin
                     (show "error: " msg)
                     rval-crashed)))
            (else rval-crashed))))) ;; some other thread is talking to me. equally bad.

