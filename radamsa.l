;;;
;;; Radamsa - a general purpose test data fuzzer
;;;

;; FIXME: crash module node is now wrong
;; todo: unit test - output with a seed to stdout, as tcp client and server, and compare the contents
;; todo: maybe should bypass thread-based io to further improve writing speed (and detect errors earlier)
;; todo: remove useless stuff from module startup lists (name now twice)
;; todo: make a priority adjustment pass and allow it to pass information back
;; todo: when using stdin as sample an making n>1 files, preread the stdin. useful especially for testing.
;; todo: stream fuzzer: cut section around delimiters and permute some slots (2-pass)
;; todo: stream fuzzer: permute n bytes
;; todo: stream fuzzer: cut&fill with probabilities
;; todo: stream fuzzer: local permu transform
;; todo: stream fuzzer: local surfy (using lazy or n-level stree)
;; todo: stream muxer: 2-stream permu
;; todo: stream muxer: 2-stream surf (lazy stree)
;; todo: have a look at mutation distributions on larger files. not sensible yet.
;; todo: muxers could return F when can't do anything, so that the meta could be removed
;; todo: node infos should be ffs of static values like name, description etc to allow something like $ radamsa --list-modules
;; todo: module startup should use (name-of node) instead of a separate string in the list
;; maybe: if the case stream would use for example seeds generated by a lagged fibonacci generator, one could seek in O(log n)
;;         ^ might make sense to thread the random state differently in this case

;; fuzzer node info → ff of (name → str, description → text, meta → meta)
(define version-str "Radamsa 0.2b")
(define avg-block-size 4096)

(import lib-args)

;; todo: stream muxer: cat a b → a ++ b, seen some bugs that needed this

(define rval-failed-to-start-modules 1)
(define rval-crashed 127) ;; in-owl thread crash after detecting an error

(define (renderer val tl)
   (render render val tl))

(define (car> a b) (> (car a) (car b)))

(define (pop-rand rs)
   (lets ((digit rs (uncons rs F))) rs))

;; force and send a stream to a port
(define (mail-blocks str port n)
   (cond
      ((pair? str)
         (lets
            ((block str str)
             (size (sizeb block)))
            (if (not (eq? size 0))
               (mail port block))
            (mail-blocks str port (+ n size))))
      ((null? str) n)
      (else (mail-blocks (str) port n))))

(define (send-stream data port)
   (let ((res (mail-blocks data port 0)))
      (flush-port port) ; <- only necessary for stdout, since others are autoflushed on close soon
      res))

;; functions that get metadata about generated data
(define (record-meta/stderr n name info len)
   (mail stderr (foldr renderer '(10) (list " " n ": " name " → " info ": " len "b"))))

(define (record-meta/not n name info len) 42)

;; todo: pass the meta recorder here
(define (get-stdout-fd n)
   (pair 
      (λ (ll record-meta)
         (let ((w (send-stream (cdr ll) stdout)))
            (record-meta n "" (car ll) w)))
      (get-stdout-fd (+ n 1))))

(define (render-ip bvec)
   (runes->string
      (foldr
         (λ (byte tl)
            (render render byte (if (null? tl) tl (cons 46 tl))))
         null bvec)))

(define (render-ip-port bvec port)
   (runes->string
      (foldr
         (λ (byte tl)
            (render render byte (if (null? tl) tl (cons 46 tl))))
         (cons 58 (render render port null))
         bvec)))

;; todo: parameterize writers to take the meta recorder
(define (file-writer pat)
   (λ (nth)
      (λ (node record-meta)
         (lets ((info ll node))
            (define path
               (runes->string
                  (str-foldr
                     (λ (char tl)
                        (cond
                           ((null? tl)
                              (cons char tl))
                           ((eq? char 37) ; %
                              (case (car tl)
                                 ((110) (render render nth (cdr tl))) ; %n
                                 ((102) (render render (get info 'name "anonimasu") (cdr tl))) ; %f
                                 (else (error "Unknown pattern in output path: " (list->string (cons char tl))))))
                           (else (cons char tl))))
                     null pat)))
            (define port 
               (open-output-file path))
            (if port
               (let ((written (send-stream ll port)))
                  (record-meta nth path info written)
                  (close-port port))
               (error "Cannot write to " path))))))

(define (in-range? min max)
   (λ (x) (and (<= min x) (<= x max))))

(define (make-tcp-connection ip port)
   (λ (n)
      (λ (node record-meta)
         (let loop ()
            (let ((try (tcp-send ip port (cdr node))))
               (cond
                  ((eq? try 'cannot-connect) ;; other end not ready to receive connection
                     (wait 100) ;; other end 
                     (loop))
                  ((number? try) ;; sent this many bytes
                     (record-meta n (render-ip-port ip port) (car node) try))
                  (else
                     ;; write error (remote likely hung up)
                     (record-meta n (render-ip-port ip port) (car node) False))))))))

(define (serve-node numbered)
   (λ (node record-meta)
      ;; todo: do a few unblocking reads because the client might block until a request is received
      (lets 
         ((nth cli numbered)
          (ip fd cli))
         (lets 
            ((ip fd cli)
             (np (blocks->fd (cdr node) fd))) ; <- closes fd
            (record-meta nth (render-ip ip) (car node) np)))))

;; str → ((info . fd) ...) | False
(define (make-output-stream str)
   (cond
      ((equal? str "-")
         (get-stdout-fd 1))
      ((/^:[0-9]+$/ str)
         (let ((port (string->integer (s/^:// str))))
            (if (and port (>= port 0) (< port 65536))
               (let ((clis (tcp-clients port)))
                  (if clis
                     (lmap serve-node (lzip cons (lnums 1) clis))
                     False))
               (begin
                  (show "Bad port " port)
                  False))))
      ((/^[0-9]{1,3}(\.[0-9]{1,3}){3}:[0-9]+$/ str)
         (lets
            ((ip-port (c/:/ str)) ;; todo: later these become 2-valued functions
             (port (string->integer (cadr ip-port)))
             (addr (map string->integer (c/\./ (car ip-port)))))
            (cond
               ((not (all (in-range? 0 255) addr))
                  (show "Bad ip address: " addr)
                  null)
               ((not ((in-range? 0 65535) port))
                  (show "Bad port: " port)
                  False)
               (else
                  (lmap (make-tcp-connection (list->vector addr) port)
                     (lnums 1))))))
      (else
         (lmap (file-writer str) (lnums 1)))))

(define basic-cl-opts
   `((help "-h" "--help" comment "Show this thing.")
     (output "-o" "--output" has-arg default "-" cook ,make-output-stream
         comment "Where to write the generated data?")
     (count "-n" "--count" cook ,string->integer check ,(λ (x) (> x 0))
         default "1" comment "How many outputs to generate?")
     (seed "-s" "--seed" has-arg comment "Random seed (any string).")
     (verbose "-v" "--verbose" comment "Be verbose when running.")
     (version "-V" "--version" comment "Show version information.")
     (examples "-E"  "--examples" comment "Show usage examples.")
     (advanced "-H"  "--big-help" comment "Show more options.")
))

(define advanced-cl-opts
   (append basic-cl-opts
      `((fuzzers "-f" "--fuzzers" has-arg default "drop,inc,dec,dup,flip,stut=3,num=4,utf8=2" 
            comment "Which stream fuzzers to run? (pass help to list options)")
        (generators "-g" "--generators" has-arg default "sample=10,flat" 
            comment "Which stream generators to run? (pass help to list options)")
        (polymerase "-p" "--polymerase" has-arg default "onced" 
            comment "Which stream mutator patterns to use? (pass help to list options)")
        (muxer-polymerase "-P" "--muxer-polymerase" has-arg default "once" 
            comment "Which muxer mutator patterns to use? (pass help to list options)")
        (muxers "-m" "--muxers" has-arg default "swap=4,cat" 
            comment "Which stream muxers to use? (pass help to list options)")
        (seek "-S" "--seek" has-arg cook ,string->integer check ,(λ (x) (>= x 0))
            comment "Skip start from nth file.")
        (single F "--single" comment "Use only one data stream per output.")
        ;(blank "-T" "--tabula-rasa" comment "Do not read any sample data.")
        )))

(define command-line-rules
   (cl-rules advanced-cl-opts))

(define usage-text "Usage: radamsa [option] [sample-path] ...")

(define (print-usage-text advanced?)
   (print usage-text)
   (print-rules (if advanced? command-line-rules (cl-rules basic-cl-opts))))

;; () → string
(define (urandom-seed)
   (let ((fd (open-input-file "/dev/urandom"))) ;; False if not there
      (if fd
         (let ((data (interact fd 8)))
            (close-port fd)
            (if (vector? data)
               (list->string 
                  (render render (fold (λ (n d) (+ d (<< n 8))) 0 data) null))
               False))
         False)))

;; () → string (decimal number)
(define (time-seed)
   (list->string (render render (time-ms) null)))

;; get a seed if none was given explicitly (use /dev/urandom or current time in ms)
(define (add-seed opts)
   (put opts 'seed
      (or (urandom-seed) (time-seed))))

;; str → integer
(define (string->seed str)
   (if (string? str)
      (fold (λ (seed digit) (* (+ digit 1) (+ seed 1))) 1 (str-iter str))
      (error "bad seed: " str)))

;; str → str | (name . priority)
(define (try-split-priority str)
   (lets ((parts (c/=/ str)))
      (cond
         ((= (length parts) 1)
            ;; no priority given. default to 1 (lowest).
            (cons 1 (car parts)))
         ((= (length parts) 2)
            (let ((pri (string->integer (cadr parts))))
               (if (and pri (> pri 0))
                  (cons pri (car parts))
                  str)))
         (else str))))

(define (split-priorities selection opts paths fail)
   (lets
      ((mods (keep (λ (x) (> (string-length x) 0)) (c/,/ selection))) ;; split
       (pris (map try-split-priority mods))
       (bads (keep string? pris)))
      (if (null? bads)
         pris
         (begin
            (for-each (λ (x) (show "Bad module selection: " x)) bads)
            (print "Modules selection is a comma-separated list of module names optionally followed by weights.")
            (print "For example -e foo,bar,baz=2 will use baz about as often as foo and bar combined.")
            (print "Use $ radamsa -e help to list options")
            (fail False)))))

(define (iterate thing)
   (pair thing (iterate thing)))

;; iterate the same thing
(define (simple-node name value)
   (let ((node (cons name value)))
      (iterate node)))

;; iterate a fuzzer function that acts like a lfold over random states
;; rs name value → (name . ((name . (val rs)) (name . (var . rs')) ...))
(define (rs-fold-node name value)
   (cons name
      (λ (rs paths opts)
         (let loop ((rs rs))
            (pair (cons name (value rs))
               (loop (pop-rand rs)))))))

;;; Stream fuzzers -----------------------------------------------------------

(define (byte-vector->list bvec)
   (let ((n (sizeb bvec)))
      (if (eq? n 0)
         null
         (let loop ((pos (- n 1)) (out null))
            (cond
               ((eq? pos 0)
                  (cons (refb bvec pos) out))
               (else
                  (lets ((posp _ (fx- pos 1)))
                     (loop posp (cons (refb bvec pos) out)))))))))

;; todo: add zero width joiners, different length leading blank padding bytes etc
(define funny-unicode
   (list->tuple
      (append
         (list ;; some manual ones
            (list #xef #xbb #xbf)  ;; the canonical utf8 bom
            (list #xfe #xff)       ;; utf16 be bom
            (list #xff #xfe)       ;; utf16 le bom
            (list 0 0 #xff #xff)   ;; ascii null be
            (list #xff #xff 0 0)   ;; ascii null le
            (list 43 47 118 56)    ;; and some others from wikipedia
            (list 43 47 118 57) (list 43 47 118 43) (list 43 47 118 47)
            (list 247 100 76) (list 221 115 102 115) (list 14 254 255) (list 251 238 40)
            (list 251 238 40 255) (list 132 49 149 51))
         (map ;; some valid points and ranges
            (λ (codepoint)
               (render render (list->string (list codepoint)) null)) ;; <- make UTF-8 repr
            (fold
            (λ (tl node)
                  (if (pair? node) ;; inclusive range
                     (append (iota (car node) 1 (+ (cdr node) 1)) tl)
                     (cons node tl)))
               null
               '((#x0009 . #x000d) #x00a0 #x1680 #x180e (#x2000 . #x200a) #x2028 #x2029 #x202f #x205f
                 #x3000 (#x200e . #x200f) (#x202a . #x202e) (#x200c . #x200d) #x0345 #x00b7 (#x02d0 . #x02d1) 
                 #xff70 (#x02b0 . #x02b8) #xfdd0 #x034f (#x115f . #x1160) (#x2065 . #x2069) #x3164 #xffa0
                 #xe0001 (#xe0020 . #xe007f) (#x0e40 . #x0e44) #x1f4a9))))))

;; clone a byte vector to a list and edit at given position (using primops since this is heavily used)
(define (edit-byte-vector bvec edit-pos fn)
   (let ((len (sizeb bvec)))
      (if (eq? len 0)
         bvec
         (let loop ((pos (- len 1)) (out null))
            (let ((val (refb bvec pos)))
               (if (eq? pos edit-pos)
                  (if (eq? pos 0)
                     (list->byte-vector (fn val out))
                     (lets ((pos _ (fx- pos 1)))
                        (loop pos (fn val out))))
                  (if (eq? pos 0)
                     (list->byte-vector (cons val out))
                     (lets ((pos _ (fx- pos 1)))
                        (loop pos (cons val out))))))))))

(define (digit-val d)
   (cond
      ((lesser? d 48) F)
      ((lesser? 57 d) F)
      (else (- d 48))))

; → digit|F tail
(define (get-num lst)
   (let loop ((lst lst) (n 0) (digits 0))
      (cond
         ((null? lst)
            (if (eq? digits 0)
               (values F null)
               (values n null)))
         ((digit-val (car lst)) =>
            (λ (d) (loop (cdr lst) (+ d (* n 10)) (+ digits 1))))
         ((eq? digits 0)
            (values F lst))
         (else
            (values n lst)))))

;; copy from pos up to end (not countin it)
(define (copy-range pos end tail)
   (if (eq? pos end)
      tail
      (cons (car pos) (copy-range (cdr pos) end tail))))

;; fixme: simple placeholder
(define (mutate-num rs num)
   (lets ((rs n (rand rs 16)))
      (cond
         ((eq? n 0)  (values rs (+ n 1)))
         ((eq? n 1)  (values rs (- n 1)))
         ((eq? n 2)  (values rs 0)) ;; todo, pack funny nums to a list and reduce opts
         ((eq? n 3)  (values rs 1))
         ((eq? n 4)  (values rs #xff))
         ((eq? n 5)  (values rs #x100))
         ((eq? n 6)  (values rs #xffff))
         ((eq? n 7)  (values rs #x10000))
         ((eq? n 8)  (values rs #x7fffffff))
         ((eq? n 9)  (values rs #x80000000))
         ((eq? n 10) (values rs #xffffffff)) ;; todo 64-bit also when using a list
         ((eq? n 11) (values rs #x100000000))
         ((eq? n 12)
            (lets ((rs m (rand rs (* n 2))))
               (values rs (- n m))))
         (else
            (lets
               ((rs n (rand-range rs 1 129))
                (rs n (rand-log rs n)))
               (values rs (+ num n)))))))

(define (mutate-a-num rs lst nfound)
   (if (null? lst)
      (lets ((rs which (rand rs nfound)))
         ;; choose which to mutate (or 0 if none)
         (values rs which null))
      (lets ((valp lstp (get-num lst)))
         (if valp
            (lets ((rs which tail (mutate-a-num rs lstp (+ nfound 1))))
               (if (eq? which 0) ;; i won
                  (lets
                     ((rs new (mutate-num rs valp))
                      (new-lst (render render new tail)))
                     (values rs -1 (render render new tail)))
                  (values rs (- which 1)
                     (copy-range lst lstp tail))))
            (lets ((rs which tail (mutate-a-num rs (cdr lst) nfound)))
               (values rs which (cons (car lst) tail)))))))

;; todo: pack stream fuzzers to the list itself
(define (sed-num rs)
   (λ (ll)
      (lets
         ((lst (vec->list (car ll)))
          (rs n lst (mutate-a-num rs lst 0)))
         (cons (list->byte-vector lst) (cdr ll)))))

(define (sed-star rs) ;; test fuzzer, replaces a character with *
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons (edit-byte-vector (car ll) p (λ (old tl) (cons 42 tl))) (cdr ll)))))

(define (sed-drop rs) ;; droa byte
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons (edit-byte-vector (car ll) p (λ (old tl) tl)) (cdr ll)))))

(define (sed-inc rs) ;; increment a byte mod 256
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons (edit-byte-vector (car ll) p (λ (old tl) (cons (band 255 (+ old 1)) tl))) (cdr ll)))))

(define (sed-flip rs) ;; flip a bit
   (λ (ll)
      (lets 
         ((rs p (rand rs (sizeb (car ll))))
          (rs b (rand rs 8)))
         (cons (edit-byte-vector (car ll) p (λ (old tl) (cons (bxor (<< 1 b) old) tl))) (cdr ll)))))

(define (sed-stut rs) ;; repeat a section
   (λ (ll)
      (lets ((n (sizeb (car ll))))
         (if (< n 4)
            ll
            (lets
               ((rs start (rand-range rs 0 (- n 2)))
                (rs end (rand-range rs (+ start 1) n))
                (pre (map (λ (p) (refb (car ll) p)) (iota 0 1 start)))
                (post (map (λ (p) (refb (car ll) p)) (iota end 1 (sizeb (car ll)))))
                (stut (list->byte-vector (map (λ (p) (refb (car ll) p)) (iota start 1 end))))
                (rs n (rand-log rs 10)) ; max 2^10 = 1024 stuts
                (stuts
                  (fold
                     (λ (tl n) (cons stut tl))
                     (if (null? post)
                        (cdr ll)
                        (cons (list->byte-vector post) (cdr ll)))
                     (iota 0 1 n))))
               (if (null? pre)
                  stuts
                  (cons (list->byte-vector pre) stuts)))))))

(define (sed-dec rs) ;; decrement a byte mod 256
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons 
            (edit-byte-vector (car ll) p 
               (λ (old tl) (if (eq? old 0) 255 (cons (- old 1) tl))))
            (cdr ll)))))

(define (sed-dup rs) ;; duplicate a byte
   (λ (ll)
      (lets ((rs p (rand rs (sizeb (car ll)))))
         (cons 
            (edit-byte-vector (car ll) p 
               (λ (old tl) (ilist old old tl)))
            (cdr ll)))))

;; insert UTF-8 that might be mishandled
(define (sed-utf8 rs)
   (λ (ll)
      (lets
         ((rs p (rand rs (sizeb (car ll))))
          (rs bytes (rand-elem rs funny-unicode)))
         (cons
            (edit-byte-vector (car ll) p (λ (old tl) (append bytes (cons old tl))))
            (cdr ll)))))

;; todo: silly boilerplate
; (name . starter), starter : rs paths opts → ((info . func) ...)
(define ll-fuzzers   
   (list
      (rs-fold-node "star" sed-star)
      (rs-fold-node "drop" sed-drop)
      (rs-fold-node "inc" sed-inc)
      (rs-fold-node "dec" sed-dec)
      (rs-fold-node "dup" sed-dup)
      (rs-fold-node "flip" sed-flip)
      (rs-fold-node "stut" sed-stut)
      (rs-fold-node "num" sed-num)
      (rs-fold-node "utf8" sed-utf8)
      (cons "crash" 'mr-crasher)))

(define (string->vec str)
   (list->byte-vector (render render str null)))

;;; Stream generators -------------------------------------------------


(define max-block-size (* 2 avg-block-size))

;; bvec|F bvec → bvec
(define (merge head tail)
   (if head
      (list->vector (vec-foldr cons (vec-foldr cons null tail) head))
      tail))

(define (rand-block-size rs)
   (lets ((rs n (rand rs max-block-size)))
      (values rs (max n 8))))

;; todo: might make sense to grow the initial block size limits as 2^n up to final limit
;; stream data from port as desired sized blocks (which are deterministic unlike the sizes we happen to read) and close it at eof
(define (stream-blocks rs port)
   (lets ((rs first (rand-block-size rs)))
      (let loop ((rs rs) (last F) (wanted first)) ;; 0 = block ready (if any)
         (let ((block (interact port wanted)))
            (cond
               ((eof? block) ;; end of stream
                  (if (not (eq? port stdin)) (close-port port))
                  (if last (list last) null))
               ((not block) ;; read error
                  ;; later carp via whatever logging system is used to stderr
                  (if (not (eq? port stdin)) (close-port port))
                  (if last (list last) null))
               ((eq? (sizeb block) (+ wanted 1))
                  ;; a block of required (deterministic) size is ready
                  (lets
                     ((block (merge last block))
                      (rs next (rand-block-size rs)))
                     (pair block (loop rs F next))))
               (else
                  (loop rs (merge last block) (- wanted (sizeb block)))))))))

(define (open-sample-port path)
   (cond
      ((equal? path "-") stdin)
      (else (open-input-file path))))

;; todo: make the first block a special case?
(define (stream-sample rs path)
   (let ((port (open-sample-port path)))
      (if port
         (stream-blocks rs port) ; <- use also for stdin streaming
         (begin
            (mail stderr (foldr renderer '(10) (list "Cannot read '" path "' - acting as if it were blank.")))
            null))))

;; todo: switch to stream mode if no samples given?
(define (sample-gen rs paths opts)
   ;; permute once per round
   (lets ((rs order (random-permutation rs paths)))
      (let loop ((rs rs) (order order))
         (if (null? order)
            (sample-gen rs paths F) ;; repermute 
            (pair
               (cons
                  (list 'sample (car order)) ;; save sample name to metadata
                  (λ () (stream-sample rs (car order))))
               (loop (pop-rand rs) (cdr order)))))))

(define (repeat thing n)
   (let loop ((n n) (out null))
      (if (eq? n 0)
         out
         (loop (- n 1) (cons thing out)))))

(define (repeat-blocks pre n tail)
   (if (= n 0)
      (list tail)
      (pair pre (repeat-blocks pre (- n 1) tail))))

(define (rand-length rs)
   (lets
      ((rs nbits (rand rs 18))
       (rs n (rand rs (<< 1 (max nbits 6)))))
      (values rs n)))

(define (sgen-flat rs paths opts)
   (let loop ((rs rs))
      (lets
         ((rs base (rand rs 256))
          (rs len (rand-length rs))
          (blocks (div len avg-block-size)))
         (pair
            (cons 
               (list 'flat base len)
               (repeat-blocks
                  (if (> blocks 0)
                     (list->byte-vector (repeat base avg-block-size))
                     'nothing)
                  blocks
                  (list->byte-vector (repeat base (- len (* blocks avg-block-size))))))
            (loop rs)))))

(define ll-generators
   (list
      (cons "sample" sample-gen)
      (cons "flat" sgen-flat)))

;;; Stream polymerases ------------------------------------------------

;; todo: once-dec could also also take a cont
;; run mutafn with prob 1/(ip+n) to block at offset n, or last if out of data

(define (once-dec rs mutafn ll)
   (lets 
      ((hd ll (uncons ll F))
       (rs ip (rand rs 32)))
      (if hd
         (let loop ((rs rs) (ll ll) (last hd) (ip ip))
            (lets ((rs n (rand rs ip)))
               (if (eq? n 0)
                  (mutafn (cons last ll))
                  (lets ((next ll (uncons ll F)))
                     (if next
                        (cons last 
                           (loop rs ll next (+ ip 1)))
                        (mutafn (list last)))))))
         ll)))

(define ll-polymerase 
   (list
      (rs-fold-node "onced" 
         (λ (rs) (λ (mutagen ll) (once-dec rs mutagen ll))))))

;;; Muxers --------------------------------------------------------------

(define ll-muxers ;; todo: many to be added in 0.2.1
   (list
      (cons "swap" ;; Simply swap streams
         (λ (rs paths opts)
            (simple-node "swap"
               (λ (a b) (values b a)))))
      (cons "cat" ;; catenate streams
         (λ (rs paths opts)
            (simple-node "cat"
               (λ (a b) (values (lappend a b) null)))))))

;; mux-step - walk the two lazy streams (whose length we don't know) and apply muxer once 
;; at some position, and then pass control to cont. blocks of a are emitted as output and 
;; b is dropped, speeds being roughly equivalent.

; → (cont ll ll)
(define (mux-step rs all bll muxer ip cont)
   (define (finish as bs)
      (cond
         ((null? as) (cont null bs))
         ((null? bs) (cont as null))
         (else 
            (lets ((as bs (muxer as bs))) 
               (cont as bs)))))
   (lets 
      ((a as (uncons all F))
       (b bs (uncons bll F)))
      (cond
         ((not a) (finish all bll)) ;; no base stream to mux
         ((not b) (finish all bll)) ;; no data to mux against
         (else
            (let loop ((rs rs) (a a) (as as) (b b) (bs bs))
               (lets ((rs n (rand rs ip)))
                  (if (eq? n 0)
                     (finish (cons a as) (cons b bs))
                     (lets ((rs n (rand rs 2)))
                        (if (eq? n 0)
                           (lets ((aa as (uncons as F)))
                              (if aa
                                 (pair a (loop rs aa as b bs)) ;; more a follows, emit and continue
                                 (finish (list a) (cons b bs)))) ;; out of a
                           (lets ((bb bs (uncons bs F)))
                              (if bb
                                 (loop rs a as bb bs) ;; more b follows, drop b an continue
                                 (loop rs a as b null)))))))))))) ;; out of b, keep last block

(define (fast-forward ll)
   (cond
      ((pair? ll) (fast-forward (cdr ll)))
      ((null? ll) ll)
      (else (fast-forward (ll)))))

(define (mux-once rs all bll muxer ip)
   (mux-step rs all bll muxer ip 
      (λ (a b) 
         (fast-forward b)   ;; read the b stream to be dropped in order to close the fd
         a)))

(define ll-muxer-polymerase 
   (list
      (rs-fold-node "once" 
         (λ (rs)
            (λ (muxer all bll)
               (lets
                  ((rs bits (rand rs 8))
                   (rs ip (rand rs (<< 1 bits)))) ;; inverse probability
                  (mux-once rs all bll muxer ip)))))))

;;; Master polymerase --------------------------------------------------------------

;; grab some streams 
(define (choose-streams rs gens)
   (let loop ((rs rs) (gens gens) (taken null))
      (lets ((rs n (rand rs (* 3 (length taken)))))
         (if (eq? n 0)
            (lets ((this gens (uncons gens F)))
               (loop rs gens (cons this taken)))
            (values rs gens taken)))))

(define (plain-sample? node) 
   (and (pair? (car node))
      (eq? (caar node) 'sample)))

;; merger many data streams to one using the fuzzers and muxers
(define (master-merge rs muxs fuzs lls)
   (lets ((rs n (rand rs 5)))
      (cond
         ((eq? n 0) ;; permute
            (lets ((rs lls (random-permutation rs lls)))
               (master-merge rs muxs fuzs lls)))
         ((eq? n 1) ;; add a stream fuzzer to first
            (lets ((fuzz fuzs (uncons fuzs F)))
               (master-merge rs muxs fuzs (cons (fuzz (car lls)) (cdr lls)))))
         ((eq? n 2) ;; merge two streams (if more than one)
            (if (not (null? (cdr lls)))
               (lets 
                  ((mux muxs (uncons muxs F))
                   (a (car lls)) (b (cadr lls)))
                  (master-merge rs muxs fuzs
                     (cons (mux a b) (cddr lls))))
               (master-merge rs muxs fuzs lls)))
         ((and (null? (cdr lls)) (not (plain-sample? (car lls)))) ;; else try exit
            (values rs muxs fuzs (car lls)))
         (else ;; else keep muxin
            (master-merge rs muxs fuzs lls)))))

;; todo: needs to act differently if only one sample which is stdin, so some special handling will be needed
(define (master-polymerase rs gens muxs fuzs)
   (lets
      ((rs gens tomux (choose-streams rs gens)) ;; choose some streams to use
       (rs muxs fuzs node (master-merge rs muxs fuzs tomux))) ;; combine them to one stream
      (pair node  ;; <- data to generate
         (master-polymerase rs gens muxs fuzs))))

;; a single-stream variant for testing stream fuzzers
(define (master-polymerase/single-stream rs gens muxs fuzs)
   (lets
      ((this gens (uncons gens F))
       (rs muxs fuzs node (master-merge rs muxs fuzs (list this))))
      (pair node  ;; <- data to generate
         (master-polymerase/single-stream rs gens muxs fuzs))))

; node : rs paths opts → ((info . value) ...)

(define max-seed #x1000000000000)

(define (pop-at opts n) ; (... (pri . ((info . val) ...)) ...) n → matching (info . val) x (... (pri . ...) ...)
   (lets
      ((node (car opts))
       (pri ll node))
      (if (< n pri)
         (lets ((next ll (uncons ll F)))
            (values next (cons (cons pri ll) (cdr opts))))
         (lets ((grabbed opts (pop-at (cdr opts) (- n pri))))
            (values grabbed (cons node opts))))))

(define (mux rs opts lim)
   (lets 
      ((rs n (rand rs lim))
       (val opts (pop-at opts n)))
      (pair val (mux rs opts lim))))

;; mux streams probabilistically according to priorities
(define (make-muxer rs opts)
   (if (null? (cdr opts))
      (values rs (cdar opts)) ;; no need to mux
      (lets
         ((rs seed (rand rs max-seed))
          (opts (sort car> opts))
          (total (fold + 0 (map car opts))))
         (values rs (mux (seed->rands seed) opts total)))))

(define (find-module mods name)
   (cond
      ((null? mods) F)
      ((equal? (caar mods) name) (cdar mods))
      (else (find-module (cdr mods) name))))

;; start node streams, each with their own rs, and mux them according to priorities
; → rs' ((info . val) ...)
(define (start rs mods pris paths opts)
   (let loop ((rs rs) (pris pris) (out null))
      (cond
         ((null? pris)
            (make-muxer rs out))
         ((find-module mods (cdar pris)) =>
            (λ (modfn)
               (lets 
                  ((rs seed (rand rs max-seed))
                   (nodes (modfn (seed->rands seed) paths opts)))
                  (loop rs (cdr pris) (cons (cons (caar pris) nodes) out)))))
         (else
            (if (not (equal? (cdar pris) "help"))
               (show "I don't have a module called " (cdar pris))) 
            (error "Valid options are " (map car mods))))))

;; merge muxer polymerase stream and muxer stream to a stream muxer stream
(define (muxer-stream pols muxs)
   (lets
      ((pol pols (uncons pols F))
       (mux muxs (uncons muxs F)))
      (pair
         (λ (aln bln)
            (lets
               ((a-info a-data aln)
                (b-info b-data bln))
               (cons
                  (list (car pol) (car mux) a-info b-info) ;; (pattern muxer str-a str-b)
                  ((cdr pol) (cdr mux) a-data b-data))))
         (muxer-stream pols muxs))))

;; ditto, but for stream muxers which take just one stream as argument
(define (fuzzer-stream pols fuzs)
   (lets
      ((pol pols (uncons pols F))
       (fuz fuzs (uncons fuzs F)))
      (pair
         (λ (aln)
            (lets ((a-info a-data aln))
               (cons
                  (list (car pol) (car fuz) a-info) ;; (pattern muxer str-a)
                  ((cdr pol) (cdr fuz) a-data)))) ;; <- be lazy
         (fuzzer-stream pols fuzs))))

(define (force-n ll n)
   (if (> n 0)
      (lets ((this ll (uncons ll F)))
         (this)
         (force-n ll (- n 1)))))
     
(define examples 
"Typical usage:
   Fuzz file.foo to fuzzed.foo
      $ cat file.foo | radamsa > fuzzed.foo

   Same but with explicitly given paths
      $ radamsa -o /tmp/fuzzed.foo file.foo

   Same but make 10 files
      $ radamsa -n 10 -o /tmp/fuzzed-%n.foo file.foo

   Same but use multiple samples from foo-files/*.foo
      $ radamsa -n 10 -o /tmp/fuzzed-%n.foo foo-files/*.foo")

(define (start-radamsa opts paths)
   (call/cc
      (λ (ret)
         (let ((fail (λ (why rval) (print why) (ret rval))))
            (cond
               ((get opts 'help F) (print-usage-text F) 0)
               ((get opts 'advanced F) (print-usage-text T) 0)
               ((get opts 'examples F) (print examples) 0)
               ((get opts 'version F)
                  (print version-str)
                  0)
               ((not (get opts 'seed F))
                  ;; make a time-based seed unless one is given explicitly
                  (start-radamsa (add-seed opts) paths))
               (else
                  (lets
                     ((f-pris  (split-priorities (get opts 'fuzzers F) opts paths fail))
                      (g-pris  (split-priorities (get opts 'generators F) opts paths fail))
                      (p-pris  (split-priorities (get opts 'polymerase F) opts paths fail))
                      (m-pris  (split-priorities (get opts 'muxers F) opts paths fail))
                      (mp-pris (split-priorities (get opts 'muxer-polymerase F) opts paths fail))
                      (seed (string->seed (get opts 'seed F)))
                      (n (get opts 'count F))
                      (paths ;; add stdin as a sample if no files given and no blank requested
                        (if (and (null? paths) (not (get opts 'blank F)))
                           '("-") paths))
                      ;; todo: map sample source generator to samples
                      (have-stdin? (mem equal? paths "-"))
                      ;; todo: preread stdin instead and keep in memory
                      (_ (if (and have-stdin? (> n 1)) (error "Cannot make more then 1 file when stdin is a sample yet: " paths)))
                      (rs (seed->rands seed))
                      (rs gens (start rs ll-generators g-pris paths opts))
                      (rs fuzs (start rs ll-fuzzers f-pris paths opts))
                      (rs pols (start rs ll-polymerase p-pris paths opts))
                      (fuzs (fuzzer-stream pols fuzs)) ;; fuse available polymerase with stream fuzzers
                      (rs muxs (start rs ll-muxers m-pris paths opts))
                      (rs mpol (start rs ll-muxer-polymerase mp-pris paths opts))
                      (muxs (muxer-stream mpol muxs)) ;; fuze available muxer polymerase with muxers
                      (master 
                        (if (or (get opts 'single F) have-stdin?)
                           master-polymerase/single-stream
                           master-polymerase))
                      (lls (master rs gens muxs fuzs))
                      (record-meta (if (get opts 'verbose F) record-meta/stderr record-meta/not))
                      (thunks ;; (thunk ...), calling causes io 
                        (lzip (λ (a b) (λ () (wait 100) (a b record-meta))) ;; <- wait in order to allow some time to write
                           (get opts 'output F)
                           lls))
                      (thunks (drop thunks (get opts 'seek 0))) ;; fast forward if --seek
                      )
                     (force-n thunks n)
                     0)))))))

(define (toy-meta)
   (bind (wait-mail)
      (λ (from msg)
         (mail from 'anon)
         (toy-meta))))

(define (bummer)
   (lets
      ((s "        ") (a " *    *    *")
       (n (list->string (list 10)))
       (b "   *  *  *") (c "* * BOOOM *  *"))
      (mail stdout (list 27 35 55 27 91 53 109))
      (print 
         (foldr string-append "" 
            (list n n s a n s b n s c n s b n s a n)))
      (mail stdout (list 27 91 48 109 10))))

(define (boom err-code a b)
   (bummer)
   (print "Radamsa stopped because something bad was about to happen. Sorry.")
   (print "Please file an issue at http://code.google.com/p/ouspg/issues/entry")
   (print "or send mail to aki.helin@ee.oulu.fi to get this fixed. Adding the")
   (print "following text and insructions to reproduce this issue will help.")
   (show "Error: " (list err-code 'a a 'b b)))

(λ (args)
   (fork-server 'meta toy-meta)
   (fork-linked-server 'radamsa
      (λ () (process-arguments (cdr args) command-line-rules usage-text start-radamsa)))
   (let ((res (wait-mail)))
      (exit-owl
         (tuple-case res
            ((radamsa msg)
               (tuple-case msg
                  ((finished rval x t) rval)
                  ((error cont msg reason) (show msg reason) 1)
                  ((crashed err-code a b) (boom err-code a b) 127)
                  (else (show "Abnormal exit: " res) 2)))
            (else
               (print "Abnormal condition.")
               3)))))

